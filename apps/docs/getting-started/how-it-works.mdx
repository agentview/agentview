---
title: "How it works?"
description: "Quick explanation of how AgentView works"
---

## Agent Endpoint

Imagine you're building a conversational agent, like a customer support chatbot. You want to have ful ownership over the AI logic, you don't want to overpay for black-box SaaS - great!

You'd probably start with a simple HTTP endpoint that takes user input and generates AI responses:

```typescript
const app = new Hono();

app.post('/chat', async (c) => {
  const { history, input } = await c.req.json();
  const output = await generateResponse([...history, input]);
  return c.json({ output });
});
```

We call this endpoint **Chat Endpoint**.

The `generateResponse` function is your AI logic. Example using OpenAI Responses API:

```typescript
const generateResponse = async (history: any[], input: any) => {
  const response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: { effort: "low", summary: "detailed" },
      instructions: "You are a helpful assistant.",
      input: [...history, input],
    });

  return response.output;
};
```

`generateResponse` function represents **stateless AI logic**. It takes all the inputs required to generate a response and returns the response, but it doesn't save nor load any state from the database.

Making `generateResponse` work well is **AI Engineering**. AgentView on purpose doesn't interfere with this, it lets you write code in any way you want.

### Chat Endpoint 

Since our Chat Endpoint just reads parameters, calls `generateResponse` function and returns output, it's also stateless. It doesn't provide persistence so if you wanted to play with an agent, you'd have to build probably a front-end app and store history of conversation in `localStorage` or something.

This is okay for prototyping and testing your agent locally but there's a huge amount of work to be done on top of it to make it production-ready:
- **Persistence** - the API should be stateful and remember session history.
- **Locking** - if you're response is being currently generated, the endpoint shouldn't allow new requests to be made.
- **Multiple sessions** - users might start multiple sessions so the API should be able to handle multiple sessions belonging to the same user.
- **Security** - endpoint should be secure, not allowing other parties from intercepting the sessions based on purely session ids.
- **Versioning** - if you release new version of your agent, you might want prevent continuation of sessions created with older versions.
- **Disconnects** - endpoint should be foolproof in terms of disconnects. User might switch tab in the browser and session should not be lost and easily resumed.
- **Validation** - endpoint should validate input and output items against the schema.

Quick you'll realise that it's not just how endpoint works, but how **others** can interact with it.
- showing sessions list
- managing users within organisations
- playground, letting users to organise
- collaboration - users should be able to share their sessions, comment, mention, get notified

All those things are not related to AI Engineering, they're stadnard boring engineering tasks. Making it all right takes a lot of time

## AgentView SDK to the rescue

AgentView handles all the boring stuff while letting you write your AI code in any way you want. It has 2 parts:
- **Cloud Server** - handles sessions, users, persistence, locking, versioning, etc. It exposes REST API called **AgentView API**. You can use it directly, but it's recommended to use SDK.
- **Studio** - extremely custommisable ("vibe-codeable") and collaborative data viewer for your agents.

All the AgentView configuration is done in code. Actually Studio is a simple React App you can extend heavily with providing custom React components, which you run locally and host it on your own domain as a static site.

Your Studio project contains `agentview.config.ts` which contains all the configuration for AgentView, it's synced with the Server.

In order to make our endpoint production-ready, we need to create an agent and provide simple schemas for input and output items:

```typescript
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              })
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
          }
        }
      ]
    }
  ]
})
```

Now let's use AgentView SDK to bulletproof your Chat Endpoint:

```typescript
const av = new AgentView({
  apiKey: process.env.AGENTVIEW_API_KEY
})

app.post('/chat', async (c) => {
  const { id, token, input } = await c.req.json(); // id - session id, token - user authentication token

  // Create a new user or authenticate if token exists.
  const user = token ? 
    await av.getUser({ token }) : 
    await av.createUser();

  // Create new session or fetch existing one and authorize user's access to the session.
  const session = id ?
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "my_agent" });

  const history = session.items;

  // Create a new run
  // 1. session is now locked - no more runs can be started until this one finishes.
  // 2. will error if session version is semver-incompatible.
  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });

  try {
    const output = await generateResponse(history, input);

    await av.updateRun({
      id: run.id,
      status: "completed",
      items: output
    });

    return c.json({
      id: session.id,
      output,
      token: user.token,
    })

  } catch (error) {

    // Mark run as failed and save error message
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
 
})

// Errors from AgentView SDK are ready to be returned via HTTP with correct status code and body.
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

Without touching `generateResponse` function, we've built a production-ready Agent Endpoint that handles persistence, locking, multiple sessions, security, versioning, validation etc.

## Studio

Studio is an extremely customisable and collaborative data viewer for your agents. Below we're providing custom components for each item of our session and also input component for playground:

```typescript highlight={14,25-31,44,48-52}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
            content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

It's all you need to look at session data, create new sessions.

### Collaboration

You can invite members of your organisation. Everybody can comment on any item like in Notion. You can also get notified on new comments.

You can later add new scores, so that users can score the output of the agent in a beautiful way.