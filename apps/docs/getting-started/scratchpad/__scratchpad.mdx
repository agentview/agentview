
## Expand the agent with tools

So far `my_super_agent` was very simple. Let's create a more advanced  example. We're gonna build a weather agent, that is capable of calling `weather_tool` for checking weather in given location.

To show the flexibility of AgentView, let's use AgentSDK instead of pure Responses API for a change:

```typescript
const weatherAgent = new Agent({
  name: 'Weather Assistant',
  model: 'gpt-5-mini',
  modelSettings: {
    reasoning: { effort: 'medium', summary: 'auto' }
  },
  instructions: 'You are a helpful general-purposeassistant. You have super skill of checking the weather for any location.',
  tools: [
    tool({
      name: 'weather_tool',
      description: 'Get weather information for a location using wttr.in',
      parameters: z.object({
        location: z.string().describe('The city name to get weather for'),
      }),
      execute: async ({ location }) => {
        const response = await fetch(`https://wttr.in/${encodeURIComponent(location)}?format=j2`);
        if (!response.ok) {
          return { error: 'Failed to fetch weather data' };
        }
        return await response.json();
      },
    })
  ],
});

app.post('/agentview/weather_agent/run', async (c) => {
  const { history, input } = parseBody(await c.req.json());

  const result = await run(weatherAgent, [...history, input]);

  return c.json({
    manifest,
    items: result.output
  })
})
```

And let's configure it in `agentview.config.tsx`:

```typescript
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    // ...
    {
      name: "weather_chat",
      url: "http://127.0.0.1:3000/agentview/weather_chat/run",
      run: {
        input: {
          schema: {
            type: "message",
            role: "user",
            content: z.string(),
          },
          displayComponent: ({ value }) => <UserMessage value={value.content} />,
          inputComponent: (props) => <UserMessageInput {...props} submit={(val) => props.submit({ content: val, type: "message", role: "user" })} />
        },
        steps: [
          {
            schema: {
              type: "reasoning",
            },
            displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.content[0]?.text} variant="muted" />,
          },
          {
            schema: {
              type: "function_call",
              name: "weather_tool",
              callId: z.string().meta({ callId: true })
            },
            displayComponent: ({ value }) => <BaseItem title="Weather Tool" value={"Checking weather in: " + JSON.parse(value.arguments).location + "..."} variant="muted" />,
            callResult: {
              schema: {
                type: "function_call_result",
                callId: z.string().meta({ callId: true })
              },
              displayComponent: ({ value }) => <WeatherComponent value={value} />
            }
          },
        ],
        output: {
          schema: {
            role: "assistant",
            type: "message",
            content: z.any(),
          },
          displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />,
        }
      }
    }
})
```

As you can see we added `steps` property in our agent definition. `steps` are all the items that go in a run after `input` and before. Most commonly it's reasoning or tool calls, but it could be handoffs in multi-agent system or actually any custom object that we need to store or display.

As you can see we use `callResult` [to finish]
