---
title: "How it works?"
description: "Quick explanation of how AgentView works"
---

## It starts with stateless AI logic

Imagine you're building a conversational agent, like a customer support chatbot. You want to have full ownership over the AI logic, you don't want to overpay for black-box SaaS - great!

The first thing you're gonna need is a HTTP endpoint that takes user input and generates AI responses. We call such endpoint a **Chat Endpoint**. Here's an example of the endpoint in TS+Hono:

```typescript
const app = new Hono();

app.post('/chat', async (c) => {
  const { history, input } = await c.req.json();
  const output = await generateResponse([...history, input]);
  return c.json({ output });
});
```

We put all the AI logic in `generateResponse` function. Here's an example using OpenAI Responses API:

```typescript
const generateResponse = async (history: any[], input: any) => {
  const response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: { effort: "low", summary: "detailed" },
      instructions: "You are a helpful assistant.",
      input: [...history, input],
    });

  return response.output;
};
```

In this example `generateResponse` it's very simple, in reality it'd gonna have prompts, tools, RAG, etc.

## Make endpoint production-ready

Our Chat Endpoint is not very practical yet. It's totally stateless and doesn't provide any persistence. If you want to play with an agent, you'd have to build a front-end app and store history of conversation in `localStorage` and send it back and forth between the client and the server.

To ship this agent, you need to handle:

| Problem | What it means |
|---------|---------------|
| **Persistence** | Store session history server-side |
| **Locking** | Prevent concurrent requests to the same session |
| **Multi-session** | Users can have multiple conversations |
| **Auth** | Secure sessions so users can only access their own |
| **Versioning** | Handle agent updates without breaking old sessions |
| **Validation** | Ensure inputs/outputs match expected schemas |
| **Disconnections** | Handle user switching tabs, losing connection, etc. |

Quick you'll realise that it's not just how endpoint works, but how **others** can interact with it.
- showing sessions list
- managing users within organisations
- playground, letting users to organise
- collaboration - users should be able to share their sessions, comment, mention, get notified

All those things are not related to AI Engineering, they're stadnard boring engineering tasks. Making it all right takes a lot of time

## AgentView SDK to the rescue

AgentView handles all the boring stuff while letting you write your AI code in any way you want. It has 2 parts:
- **Cloud Server** - handles sessions, users, persistence, locking, versioning, etc. It exposes REST API called **AgentView API**. You can use it directly, but it's recommended to use SDK.
- **Studio** - extremely custommisable ("vibe-codeable") and collaborative data viewer for your agents.

All the AgentView configuration is done in code. Actually Studio is a simple React App you can extend heavily with providing custom React components, which you run locally and host it on your own domain as a static site.

Your Studio project contains `agentview.config.ts` which contains all the configuration for AgentView, it's synced with the Server.

In order to make our endpoint production-ready, we need to create an agent and provide simple schemas for input and output items:

```typescript
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
          },
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
          }
        }
      ]
    }
  ]
})
```

Now let's use AgentView SDK to bulletproof your Chat Endpoint:

```typescript
const av = new AgentView({
  apiKey: process.env.AGENTVIEW_API_KEY
})

app.post('/chat', async (c) => {
  const { id, token, input } = await c.req.json(); // id - session id, token - user authentication token

  // Create a new user or authenticate if token exists.
  const user = token ? 
    await av.getUser({ token }) : 
    await av.createUser();

  // Create new session or fetch existing one and authorize user's access to the session.
  const session = id ?
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "my_agent" });

  const history = session.items;

  // Create a new run
  // 1. session is now locked - no more runs can be started until this one finishes.
  // 2. will error if session version is semver-incompatible.
  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });

  try {
    const output = await generateResponse(history, input);

    await av.updateRun({
      id: run.id,
      status: "completed",
      items: output
    });

    return c.json({
      id: session.id,
      output,
      token: user.token,
    })

  } catch (error) {

    // Mark run as failed and save error message
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
 
})

// Errors from AgentView SDK are ready to be returned via HTTP with correct status code and body.
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

Without touching `generateResponse` function, we've built a production-ready Agent Endpoint that handles persistence, locking, multiple sessions, security, versioning, validation etc.

### Flexible data format

AgentView stores your session data in extremely simple and powerful data format. In essenese, each session data is just an array of items, wehere each item can have absolutely arbitrary schema. Each object like session, run or item can be also extended with metadata. 

## Studio - vibe-codeable data viewer

AgentView comes with an extremely customisable and collaborative data viewer for your agent data.

(WRITE THAT THIS IS VERY DIFFERNET ARCHITECTURE. THAT YOU HOST YOUR OWN APP).

Here's important note from Hamel (your should read Hamel):

>  #### The Most Important AI Investment: A Simple Data Viewer
> The single most impactful investment I’ve seen AI teams make isn’t a fancy evaluation dashboard – it’s building a customized interface that lets anyone examine what their AI is actually doing. I emphasize customized because every domain has unique needs that off-the-shelf tools rarely address. When reviewing apartment leasing conversations, you need to see the full chat history and scheduling context. For real estate queries, you need the property details and source documents right there. Even small UX decisions – like where to place metadata or which filters to expose – can make the difference between a tool people actually use and one they avoid.

Studio is the app you can confogure with your custom React components. Let's define how our agent items are displayed and how the input component looks like:


```typescript highlight={14,25-31,44,48-52}
export default defineConfig({
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
            content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

Now you can easily add test sessions withing the viewer and see the results in a domain-specific way.

### Collaboration

Studio is collaborative. You can invite members of your organisation. Everybody can comment on any item like in Notion. You can also get notified on new comments.

### Scores

You can define custom scores for each item, provide custom components for them. 

### Further customisation

Studio allows you to **customise everything**. Session Card view, add custom pages, customise new session screen to prefill required metadata etc.

The architectural goal of Studio is to make it vibe-codeable. We provide you with a "good frame" (a design system, good practices), you fill it with your custom stuff.