---
title: "How it works?"
description: "Quick explanation of how AgentView works"
---

## What it takes to build an agent?

Imagine you're building a conversational agent, like a customer support chatbot. You want to have full ownership over the AI logic instead of paying for black-box SaaS. Good call!

The first thing you're gonna need is a HTTP endpoint that takes user input and generates AI responses. We call such endpoint a **Chat Endpoint**. Here's an example of the endpoint in TS+Hono:

```typescript
const app = new Hono();

app.post('/chat', async (c) => {
  const { history, input } = await c.req.json();
  const output = await generateResponse([...history, input]);
  return c.json({ output });
});
```

All the AI logic is in a **stateless** `generateResponse` function. Here's an example using OpenAI Responses API:

```typescript
const generateResponse = async (messages: any[]) => {
  const response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: { effort: "low", summary: "detailed" },
      instructions: "You are a helpful assistant.",
      input: messages,
    });

  return response.output;
};
```

For the demo purposes `generateResponse` is very simple, it's just a single LLM call. In reality all the **AI Engineering** will go there: prompts, tools, RAG, etc.

The core idea behind AgentView is that **you can build your AI logic however you want**. You can use an AI framework like LangGraph, AI SDK, or go vanilla. Actually, your Chat Endpoint can be in Python, Typescript or any other language you prefer. We believe it's too early to say which abstraction layer is the best, so AgentView is **framework- and language-agnostic for the AI part**.

### There's a lot of work around your AI logic

Even if you made your AI logic work well enough, there's still *a lot* to do. For example, our Chat Endpoint doesn't provide persistence. If you build a web UI to play with your agent you'll have to store conversation history in `localStorage` and send it all back and forth between the client and the server. Of course, it's not something you want in production.

Persistence is just one of the problems you need to handle. Here's a full list of things you need to consider:

| Problem | What it means |
|---------|---------------|
| **Persistence** | Store session history server-side |
| **Locking** | Prevent concurrent requests to the same session |
| **Multi-session** | Users can have multiple conversations |
| **Auth** | Secure sessions so users can only access their own |
| **Versioning** | Handle agent updates without breaking old sessions |
| **Validation** | Ensure inputs/outputs match expected schemas |
| **Disconnections** | Handle user switching tabs, losing connection, etc. |

This is just a **backend** part.

As you progress you'll quickly realise there's also a big chunk of **front-end** work to be done. You'll need an environment where people can play with your agent and collaborate on the outputs. I think a good analogy is a CMS. You might build a website, but there's still need to be an app where non-technical users can work on it: collaborate on content, preview, etc.

| Problem | What it means |
|---------|---------------|
| **Browsing sessions** | Showing sessions list |
| **Managing users** | Creating, updating, deleting users |
| **Playground** | Playing around with your agent without breaking production |
| **Collaboration** | Users should be able to share their sessions, comment, mention, get notified |

Both **backend** and **front-end** parts are not really **AI logic**, they're stadnard boring engineering tasks.

### AgentView handles the non-AI stuff

The job of AgentView is to handle all the non-AI stuff for you without contraining how you build your AI logic. AgentView is 2 parts:
- **Backend for conversational agents**. It provides hosted API and SDKs to create, manage and access sessions, runs, items, users, etc.
- **Studio**. An ultra-flexible and collaborative data viewer for your agents. It allows you to view, debug, run playgrounds, and collaborate with your team. It's self-hosted and open-source React app.

Let's quickly see how they work in practice.

### Backend - bulletproof your Chat Endpoint

As we already mentioned, our Chat Endpoint is stateless and therefore not very practical. It doesn't provide persistence or any other features mentioned above.

Below is the same Chat Endpoint but with AgentView SDK functions applied. Read the comments to understand what's happening.

```typescript
const av = new AgentView({
  apiKey: process.env.AGENTVIEW_API_KEY
})

app.post('/chat', async (c) => {
  // instead of taking entire converation history we take:
  // 1. id - session id
  // 2. token - user authentication token
  // 3. input - the last user message
  const { id, token, input } = await c.req.json(); 

  // Create a new user or authenticate if token exists.
  const user = token ? 
    await av.getUser({ token }) : 
    await av.createUser();

  // Create new session or fetch existing one and authorize user's access to the session.
  const session = id ?
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "my_agent" });

  const history = session.items;

  // Create a new run
  // 1. session is now locked - no more runs can be started until this one finishes.
  // 2. will error if session has incompatible version
  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });

  try {
    // Stateless AI logic stays the same!
    const output = await generateResponse([...history, input]);

    // Save output items, mark run as completed (release the lock)
    await av.updateRun({
      id: run.id,
      status: "completed",
      items: output
    });

    return c.json({
      id: session.id,
      output,
      token: user.token,
    })

  } catch (error) {

    // Mark run as failed and save error message (release the lock)
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
 
})

// Errors from AgentView SDK are ready to be returned via HTTP with correct status code and body.
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

One last thing to be done is to add `my_agent` to the AgentView configuration. It can be done via `agentview.config.ts` file:

```typescript
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
          },
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
          }
        }
      ]
    }
  ]
})
```

Voila, that's all you need!

With a bunch of simple SDK calls we've built a production-ready stateful Agent Endpoint that handles persistence, locking, multiple sessions, security, versioning and validation. All **without any constraints on how you build your AI logic**, and **without any extra backend code**.



<Tip>
#### Data format? Array is all you need.

You might be wondering how AgentView stores your session data. The answer is simple:
1. It's just an array of items with arbitrary JSON schema. They can be anything but most often it's user or assistant messages, reasoning blocks, tool calls, agent hand-offs, etc.
2. Every object like session, run or item can be also extended with custom metadata.
3. Each session might have additional `state` object that can change over time.

We believe such format is flexible enough to handle most of the agentic use cases
</Tip>

## Studio - a vibe-codeable data viewer

AgentView comes with Studio: an **extremely customisable** and **collaborative** data viewer for your agent data. The major inspiration for Studio comes [from Hamel](https://hamel.dev/blog/posts/field-guide/#the-most-important-ai-investment-a-simple-data-viewer/) (if you build agents, Hamel is a must-read):

> #### The Most Important AI Investment: A Simple Data Viewer
> 
> The single most impactful investment I’ve seen AI teams make isn’t a fancy evaluation dashboard – it’s building a customized interface that lets anyone examine what their AI is actually doing. I emphasize customized because every domain has unique needs that off-the-shelf tools rarely address. When reviewing apartment leasing conversations, you need to see the full chat history and scheduling context. For real estate queries, you need the property details and source documents right there. Even small UX decisions – like where to place metadata or which filters to expose – can make the difference between a tool people actually use and one they avoid.

We agree with Hamel 100%. You **need** a great data viewer and it should meet following criteria:
- **Customisable and domain-specific** - it should be tailored to the specific domain of your agent.
- **Collaborative** - it should be possible to collaborate with your team on the data.
- **Great UX** - it must be **extremely** easy to use for humans, especially non-technical ones, as they're often the domain experts that will tell you if your agent is working as expected.
- **Beautiful** - because things just should be beautiful

In order to allow for customisation, Studio is **not** a standard centralised SaaS front-end. It's a React package you run locally, and then host it on your own domain as a static site. Such architecture makes it trivial to customise any part of the experience simply by providing custom React components in your codebase. It makes Studio **vibe-codeable**, which we believe is the future. We provide design system and good practices, but you're free to override.

Here's how you can provide custom components for your agent items and the input component for playground:

```typescript highlight={14,25-31,44,48-52}
export default defineConfig({
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
            content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

This is all you need to allow for following features (video below):
- browse sessions
- invite team members
- comment on every session item in a sidebar like in Google Docs
- get notified on the new activity
- create new playground sessions and share them with teammates

(VIDEO TO BE ADDED)

Studio allows you to **customise everything**: session cards, scores, custom pages, lists, new session screen to prefill required metadata, etc.
