---
title: "How it works?"
description: "Quick explanation of how AgentView works"
---

Imagine you're building a conversational agent, like a customer support chatbot. You want to have full ownership over the AI logic instead of paying for black-box SaaS. Good call!

The first thing you're gonna need is a HTTP endpoint that takes user input and generates AI responses. We call such endpoint a **Chat Endpoint**. Here's an example of the endpoint in TS+Hono:

```typescript
const app = new Hono();

app.post('/chat', async (c) => {
  const { history, input } = await c.req.json();
  const output = await generateResponse([...history, input]);
  return c.json({ output });
});
```

All the AI logic is in a **stateless** `generateResponse` function. Here's an example using OpenAI Responses API:

```typescript
const generateResponse = async (messages: any[]) => {
  const response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: { effort: "low", summary: "detailed" },
      instructions: "You are a helpful assistant.",
      input: messages,
    });

  return response.output;
};
```

For the demo purposes `generateResponse` is very simple, it's just a single LLM call. In reality all the **AI Engineering** will go there: prompts, tools, RAG, etc.

The core idea behind AgentView is that **you can build your AI logic however you want**. You can use an AI framework like LangGraph, AI SDK, or go vanilla. Actually, your Chat Endpoint can be in Python, Typescript or any other language you prefer. We believe it's too early to say which abstraction layer is the best, so AgentView is **framework- and language-agnostic for the AI part**.

### There's a lot of work around your AI logic

Even if you made your AI logic work well enough, there's still *a lot* to do. For example, our Chat Endpoint doesn't provide persistence. If you build a web UI to play with your agent you'll have to store conversation history in `localStorage` and send it all back and forth between the client and the server. Of course, it's not something you want in production.

Persistence is just one of the problems you need to handle. Here's a full list of things you need to consider:

| Problem | What it means |
|---------|---------------|
| **Persistence** | Store session history server-side |
| **Locking** | Prevent concurrent requests to the same session |
| **Multi-session** | Users can have multiple conversations |
| **Auth** | Secure sessions so users can only access their own |
| **Versioning** | Handle agent updates without breaking old sessions |
| **Validation** | Ensure inputs/outputs match expected schemas |
| **Disconnections** | Handle user switching tabs, losing connection, etc. |

This is just a **backend** part.

As you progress you'll quickly realise there's also a big chunk of **front-end** work to be done. You'll need an environment where people can play with your agent and collaborate on the outputs. I think a good analogy is a CMS. You might build a website, but there's still need to be an app where non-technical users can work on it: collaborate on content, preview, etc.

| Problem | What it means |
|---------|---------------|
| **Browsing sessions** | Showing sessions list |
| **Managing users** | Creating, updating, deleting users |
| **Playground** | Playing around with your agent without breaking production |
| **Collaboration** | Users should be able to share their sessions, comment, mention, get notified |

Both **backend** and **front-end** parts are not really **AI logic**, they're stadnard boring engineering tasks.

### AgentView handles the non-AI stuff

The job of AgentView is to handle all the non-AI stuff for you without contraining how you build your AI logic. AgentView is 2 parts:
- **Backend for conversational agents**. It provides API and SDKs to create, manage and access sessions, runs, items, users, etc.
- **Studio**. An ultra-flexible and collaborative data viewer for your agents. It allows you to view, debug, run playgrounds, and collaborate with your team.

Let's quickly see how they work in practice.

### Backend - bulletproof your Chat Endpoint

As we already mentioned, our Chat Endpoint is stateless and therefore not very practical. It doesn't provide persistence or any other features mentioned above.

Below is the same Chat Endpoint but with AgentView SDK functions applied:

```typescript
const av = new AgentView({
  apiKey: process.env.AGENTVIEW_API_KEY
})

app.post('/chat', async (c) => {
  const { id, token, input } = await c.req.json(); // id - session id, token - user authentication token

  const user = token ? 
    await av.getUser({ token }) : 
    await av.createUser();

  const session = id ?
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "my_agent" });

  const history = session.items;

  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });

  try {
    const output = await generateResponse(history, input);

    await av.updateRun({
      id: run.id,
      status: "completed",
      items: output
    });

    return c.json({
      id: session.id,
      output,
      token: user.token,
    })

  } catch (error) {

    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
 
})

app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

Let's break down what's happening here line by line:

```typescript
app.post('/chat', async (c) => {
  const { id, token, input } = await c.req.json();

  // ...
```

Instead of taking entire conversation history as an input, we're requiring only the last user message - `input`. In order to make it work, we need to know the session identifier - `id`.

`token` is a user authentication token.

```typescript
const user = token ?
  await av.getUser({ token }) : 
  await av.createUser();
```

AgentView backend has a concept of **User**. User is an entity that can have multiple sessions and soon memory.

In this line, if no `token` is provided, a new user is created. If `token` is provided, the user is authenticated and the existing user is returned. If a wrong token is given, the operation will throw an error.

```typescript
const session = id ?
  await av.as(user).getSession({ id }) : 
  await av.as(user).createSession({ agent: "my_agent" });
```

In this line we either create or get a new session. AgentView validates whether user has access to the session.

```typescript
const history = session.items;
```

We get the session items - the conversation history.

```typescript
  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });
```

In this line we initiate a run. A couple of things happen here:
1. This command makes the session locked (`in_progress` status). `createRun` will throw an error if the session is already locked, so your endpoint is protected from being called multiple times concurrently.
2. You provide an agent version, in this case it's `0.0.1`. AgentView uses semantic versioning so if you made a breaking change in your agent, the session is prevented from being continued.

```ts
  try {
    const output = await generateResponse(history, input);
```

In `try {}` block we call our `generateResponse` function. Nothing changed here, it's still the same stateless AI logic you fully control.

`output` is an array of new items (assistant message + optional reasoning items)

```ts
await av.updateRun({
  id: run.id,
  status: "completed",
  items: output
});
```

On success, we append all the items to the run and mark it as completed. The lock is released.

```ts
} catch (error) {

    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
```

If an error occured, we mark the run as failed and save the error message in the history.

```ts
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

When AgentView SDK throws an error, it's always an instance of `AgentViewError` with `details` and `statusCode`. Thanks to this your endpoint will return correct HTTP error code and body on error.


.

.

.

.


.

.


.

.


.

.


.

.


.

.


.

.


.

.


.

.


.

.


.

.


.

.
















AgentView is a backend for your conversational agent.



AgentView provides 2 things:
- backend for conversational agents. It provides API and SDK to create, manage and access sessions, runs, items, users, etc.
- front-end for collaborative data viewer. It allows you to view, debug, run playgrounds, and collaborate with your team.



AgentView handles all the boring stuff while letting you write your AI code in any way you want. It has 2 parts:
- **Cloud Server** - handles sessions, users, persistence, locking, versioning, etc. It exposes REST API called **AgentView API**. You can use it directly, but it's recommended to use SDK.
- **Studio** - extremely custommisable ("vibe-codeable") and collaborative data viewer for your agents.

All the AgentView configuration is done in code. Actually Studio is a simple React App you can extend heavily with providing custom React components, which you run locally and host it on your own domain as a static site.

Your Studio project contains `agentview.config.ts` which contains all the configuration for AgentView, it's synced with the Server.

In order to make our endpoint production-ready, we need to create an agent and provide simple schemas for input and output items:

```typescript
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
          },
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
          }
        }
      ]
    }
  ]
})
```

Now let's use AgentView SDK to bulletproof your Chat Endpoint:

```typescript
const av = new AgentView({
  apiKey: process.env.AGENTVIEW_API_KEY
})

app.post('/chat', async (c) => {
  const { id, token, input } = await c.req.json(); // id - session id, token - user authentication token

  // Create a new user or authenticate if token exists.
  const user = token ? 
    await av.getUser({ token }) : 
    await av.createUser();

  // Create new session or fetch existing one and authorize user's access to the session.
  const session = id ?
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "my_agent" });

  const history = session.items;

  // Create a new run
  // 1. session is now locked - no more runs can be started until this one finishes.
  // 2. will error if session version is semver-incompatible.
  const run = await av.createRun({ 
    sessionId: session.id,
    items: [input], 
    version: "0.0.1"
  });

  try {
    const output = await generateResponse(history, input);

    await av.updateRun({
      id: run.id,
      status: "completed",
      items: output
    });

    return c.json({
      id: session.id,
      output,
      token: user.token,
    })

  } catch (error) {

    // Mark run as failed and save error message
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }
 
})

// Errors from AgentView SDK are ready to be returned via HTTP with correct status code and body.
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

Without touching `generateResponse` function, we've built a production-ready Agent Endpoint that handles persistence, locking, multiple sessions, security, versioning, validation etc.

### Flexible data format

AgentView stores your session data in extremely simple and powerful data format. In essenese, each session data is just an array of items, wehere each item can have absolutely arbitrary schema. Each object like session, run or item can be also extended with metadata. 

## Studio - vibe-codeable data viewer

AgentView comes with an extremely customisable and collaborative data viewer for your agent data.

(WRITE THAT THIS IS VERY DIFFERNET ARCHITECTURE. THAT YOU HOST YOUR OWN APP).

Here's important note from Hamel (your should read Hamel):

>  #### The Most Important AI Investment: A Simple Data Viewer
> The single most impactful investment I’ve seen AI teams make isn’t a fancy evaluation dashboard – it’s building a customized interface that lets anyone examine what their AI is actually doing. I emphasize customized because every domain has unique needs that off-the-shelf tools rarely address. When reviewing apartment leasing conversations, you need to see the full chat history and scheduling context. For real estate queries, you need the property details and source documents right there. Even small UX decisions – like where to place metadata or which filters to expose – can make the difference between a tool people actually use and one they avoid.

Studio is the app you can confogure with your custom React components. Let's define how our agent items are displayed and how the input component looks like:


```typescript highlight={14,25-31,44,48-52}
export default defineConfig({
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
            content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

Now you can easily add test sessions withing the viewer and see the results in a domain-specific way.

### Collaboration

Studio is collaborative. You can invite members of your organisation. Everybody can comment on any item like in Notion. You can also get notified on new comments.

### Scores

You can define custom scores for each item, provide custom components for them. 

### Further customisation

Studio allows you to **customise everything**. Session Card view, add custom pages, customise new session screen to prefill required metadata etc.

The architectural goal of Studio is to make it vibe-codeable. We provide you with a "good frame" (a design system, good practices), you fill it with your custom stuff.