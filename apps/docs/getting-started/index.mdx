---
title: "Introduction"
description: "Welcome to the AgentView documentation"
---

## What is AgentView?

AgentView is a scaffolding for building conversational agents like customer support bots, shopping assistants, and more. It has 2 parts:
1. Beautiful and extremely customisable Data Viewer with collaboration features.
2. Backend for session storage, user authentication, versioning, and more.

Most importantly, AgentView is **framework/language-agnostic in terms of AI code**. Most â€œAI frameworksâ€ force you into their SDK or hosted backend. AgentView flips that model - it **wraps around** your AI, not inside it.

It means you can write AI in Python, TS using any framework of your choice **or** without any framework at all. 

This analogy might but controversial, but it feels like a "CMS", but for agents.

## Example

Imagine you're building a chat agent using OpenAI Responses API. The most trivial version would be a stateless HTTP endpoint that takes user conversation history, user input and generates a response using OpenAI Responses API.

```typescript
import { Hono } from 'hono'
import { OpenAI } from 'openai';
import { AgentView } from "agentview";

const app = new Hono();
const client = new OpenAI()

app.post('/chat', async (c) => {
  const { history, input } = await c.req.json();

  let response : Awaited<ReturnType<typeof client.responses.create>>;
  try {
    response = await client.responses.create({
      model: "gpt-5-nano",
      instructions: "Be a nice agent.",
      input: [...history, input]
    });
  } catch (error) {
    console.error(error);
    throw error;
  }

  // send response
  return c.json({
    output: [...response.output],
  })
})
```

This is a good start but you need much more to go to production:
1. **Persistence** - the messages must be stored somewhere so that you can retrieve them later
2. **Stateful API** - you want to send only the new message, not send entire history back and forth
3. **User management and authentication** - "can this user access this session?"
4. **Versioning** - what if you released new version of an agent but user has old incompatible history?
5. **Validation** - you want to validate the input and output of your agent.
6. **Data Viewer** - you need a place where all the stakeholders can play around with your agent, leave comments and collaborate.

And much more...

AgentView provides all of those things without constraints on how you write your AI logic. Below is an example of how you could extend your code to add all of those things:


```typescript {8-12,16-26, 38-44, 48-53}
import { Hono } from 'hono'
import { OpenAI } from 'openai';
import { AgentView } from "agentview";

const app = new Hono();
const client = new OpenAI()

const av = new AgentView({
  apiUrl: "http://localhost:1990",
  apiKey: "AGENTVIEW_PERSONAL_SECRET_KEY",
})

app.post('/chat', async (c) => {
  const { id, input, token } = await c.req.json();

  const user = token ? await av.getUser({ token }) : await av.createUser();

  const session = id ? 
    await av.as(user).getSession({ id }) : 
    await av.as(user).createSession({ agent: "simple_chat" });

  const run = await av.createRun({ 
    sessionId: session.id, 
    items: [input], 
    version: "0.1.0" 
  });

  // generate AI response, read session.history to get previous messages
  let response : Awaited<ReturnType<typeof client.responses.create>>;
  try {
    response = await client.responses.create({
      model: "gpt-5-nano",
      instructions: "Be a nice agent.",
      input: [...session.history, input]
    });

  } catch (error) {
    await av.updateRun({ // on error mark run as failed and save error message
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });
    throw error;
  }

  av.updateRun({ // on success, save items and mark run as complete
    id: run.id,
    items: [...response.output],
    status: "complete",
  })

  // send response
  return c.json({
    id: session.id,
    output: [...response.output],
    token: user.token,
  })
})
```
AgentView builds everything around your AI so you can focus on what matters.

```tsx
export default defineConfig({
  agents: [
    {
      name: "my_chat",
      url: "http://localhost:3000/agentview",
      run: {
        input: {
          schema: z.looseObject({
            type: z.literal("message"),
            role: z.literal("user"),
            content: z.string()
          }),
          displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
          inputComponent: (props) => <UserMessagInput {...props} onSubmit={() => ...}/>
        },
        steps: [
          {
            schema: z.looseObject({
              type: z.literal("reasoning"),
              content: z.string()
            }),
            displayComponent: ({ data }) => <StepBlock>{data.content}</StepBlock>
          }
        ]
        output: {
          schema: z.looseObject({
            type: z.literal("message"),
            role: z.literal("assistant"),
            content: z.string(),
          }),
          displayComponent: ({ data }) => <AssistantMessage>{data.content}</AssistantMessage>,
        }
      }
    }
  ]
})
```

### ðŸ§© Studio - a customisable data viewer

A powerful, collaborative interface for developing and debugging agents.

- view and debug conversations
- create test sessions easily, share with the team if needed
- comment collaboratively on agent outputs (Notion-style). Mentions, notifications.
- score outputs with teammates or domain experts
- manage users, permissions, and teams

AgentView Studio is not a cloud, fixed web app. It's a React package, where you provide your configuration with code. It makes it trivial to provide custom components for session views, custom messages, custom input forms, custom pages, whatever you need. However, it enforces certain design system to keep the Notion-like collaboration features working out-of-the-box.

### ðŸ’¾ Server - storage & middleware

AgentViewâ€™s server takes care of all the glue you shouldnâ€™t have to build yourself:

- conversation storage and retrieval
- clean, stateful APIs for integration
- session management, reconnections, and resumable long-running chats
- (soon) integrations with communication channels (email, Slack, WhatsApp, voice, etc.)
- (soon) human hand-offs â€” easily route a conversation to a person when needed

## Test

[View code](https://github.com/easyblockshq/easyblocks/blob/main/.prettierignore)
