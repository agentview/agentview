---
title: "Quick Start"
description: "Start building with AgentView in minutes"
---

This guide will walk through setting up your first agent with AgentView. Along the way, you'll learn more about the concepts that are fundamental to using the SDK in your own projects.

### Create a project

Start by creating AgentView project:

```bash
npm create agentview@latest my-agentview-project
```

This will install example project in `my-agentview-project/` dir. Go to the project:

```
cd my-agentview-project
```

The root directory of the project has a following structure:
1. `studio/` - data viewer React app
2. `agent-python/` - demo Agent Endpoint written in Python + FastAPI
3. `agent-typescript/` - demo Agent Endpoint written in TS + Hono
4. `docker-compose.yml` - since there's no cloud yet, you'll need to set up AgentView Server via docker-compose.

Depending on preference how you want to write AI code you can use either `ai-python/` or `agent-typescript/`. You'll need `studio/` in both cases.

### Run AgentView Server

<Note>AgentView is in beta, so for now you have to self-host the server. We're working on the cloud service, keep an eye on updates!</Note>

To run AgentView server locally you need to install it via docker compose. Just run:

```bash
docker compose up -d
```

Visit `http://localhost:1990/api/status` to see if the server is running. If you get 200 response with `{ "status": "ok", ... }` it means it's all good.

AgentView server exposes AgentView API, which is used by Studio and your apps. 


### Install Studio

Before we continue, let's install and run the studio:

```bash
cd studio
npm install
npm run dev
```

Now go to the `localhost:1989` URL and register as the first admin user.

### Generate API Key

Go to `Settings > API Keys` and grab your personal API key.

### Configure your first agent

The most important file in the AgentView ecosystem is `agentview.config.tsx`. It lives in your Studio project (`studio/agentview.config.tsx`), but it's automatically synced with the AgentView Server.

Let's take a look at it:

```typescript
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              role: z.literal("assistant"),
              type: z.literal("message"),
              content: z.any(),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/chat/simple", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
    // other agents...
  ]
```

In this file we defined a simple agent called `simple_chat`. It has one run type with input, output and reasoning step determined by Zod schemas.

`apiBaseUrl` is the location of AgentView Server.

`inputComponent` and `displayComponent` define how the input and output will be displayed in the Studio, we'll cover them later.


### Your Agent Endpoint

When you build an AI agent you have to create a HTTP endpoint that takes user message and generates AI responses. We call this endpoint "Agent Endpoint".

With AgentView you can write your Agent Endpoint in any language or framework you want. AgentView helps you with storing and retrieving sessions and runs, error handling, versioning and managing session lifecycle.

The example Agent Endpoint in Typescript is in `agent-typescript`. Let's run it:

```
cd agent-typescript
npm install
npm run dev
```

Your Agent Endpoint server should be running at `localhost:3000`.

Let's take a look at `src/index.ts`:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';
import { cors } from 'hono/cors';

const app = new Hono();
const client = new OpenAI()
const av = new AgentView({
  apiUrl: 'http://localhost:1990',
  apiKey: process.env.AGENTVIEW_API_KEY!
})

app.use('*', cors({
  origin: ['http://localhost:1989'],
  credentials: true,
}))

// beautiful error handling
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});

app.post('/chat/simple', async (c) => {
  const { id, token, input } = await c.req.json();

  const endUser = token ? 
    await av.getEndUser({ token }) : 
    await av.createEndUser();

  const session = id ?
    await av.as(endUser).getSession({ id }) : 
    await av.as(endUser).createSession({ agent: "simple_chat" });

  const run = await av.createRun({ 
    sessionId: session.id, 
    items: [input], 
    version: "0.0.1"
  });

  let response : Awaited<ReturnType<typeof client.responses.create>>;

  try {
    // Your stateless AI agent logic goes here
    response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: {
        effort: "low",
        summary: "detailed"
      },
      input: [...session.history, input]
    });

  } catch (error) {
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }

  await av.updateRun({
    id: run.id,
    status: "completed",
    items: response.output
  });

  return c.json({
    id: session.id,
    output: response.output,
    token: endUser.token,
  })
})

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

It's a simple Hono HTTP server with a single endpoint `POST /chat/simple`. 

In this example your AI logic is a simple call to OpenAI Responses API:

```typescript    
    response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: {
        effort: "low",
        summary: "detailed"
      },
      input: [...session.history, input]
    });
```

In practice it could be any framework or your choice, AgentView stays completely agnostic in this regard.

AgentView handles everything **around** your AI logic:
- authenticates and creates end users
- fetches existing session or creates a new one, authorizes user's access to the session
- creates a run, which locks the session for the duration of the run (new calls for this session while run is in progress will fail)
- `session.history` provides the conversation history required by the AI logic
- validates whether the run version is compatible with the initial session version
- stores the response items in the session history, or error message for failed runs
- validates all the items against the schemas from the agent config

All errors from AgentView SDK come with status code and body, so that you can easily redirect it directly to the user as HTTP response:

```typescript
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

The goal is so that you focus on AI logic and not on the scaffolding.

### Test your agent

Call your Agent Endpoint to initiate a new conversation:

```bash
curl -X POST https://localhost:3000/chat/simple \
  -H "Content-Type: application/json" \
  -d '{
    "input": { "type": "message", "role": "user", "content": "Hello, I'm Bob, how are you?" }
  }'
```

Result:

```json
{
  "id": "a2ce2d7a-3869-4ec0-aa22-d7cbaf09fb46",
  "output": [
    {
      "id": "rs_03e64139f60c639700692eeb4b012c81a0b3077f41a8c34778",
      "type": "reasoning",
      "summary": []
    },
    {
      "id": "msg_03e64139f60c639700692eeb4c046c81a0bc071eff9a93fb36",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "annotations": [],
          "logprobs": [],
          "text": "Hi Bob! Iâ€™m doing well, thanks for asking. How can I help you today?"
        }
      ],
      "role": "assistant"
    }
  ],
  "token": "142c646f9e5022adcf0b9dcac4e5707b1385a7d017f5bb9b00c448876e372bf1"
}
```

Let's continue the thread by sending new message

```bash
curl -X POST https://localhost:3000/chat/simple \
  -H "Content-Type: application/json" \
  -d '{
    "id": "SESSION_ID",
    "input": {"type": "message", "role": "user", "content": "Hello, what was my name again?"},
    "token": "END_USER_TOKEN"
  }'
```

You should get a response:

(TODO)

```json
{
  "id": "SESSION_ID",
  "output": [
    {
      "type": "reasoning",
      "content": "Thinking..."
    },
    {
      "type": "message",
      "role": "assistant",
      "content": "Your name is Bob, how can I help you today?"
    }
  ],
  "token": "END_USER_TOKEN"
}
```

As you can see the AgentView correctly stores the conversation history and remembers the context of the conversation.

### Error cases

Let's send an incorrect input:

```bash
curl -X POST https://localhost:3000/chat/simple \
  -H "Content-Type: application/json" \
  -d '{
    "id": "SESSION_ID",
    "input": {"type": "message", "role": "user", "content": 100}
    "token": "END_USER_TOKEN"
  }'
```

This triggers 422 error, as the input is not a string. Let's send a correct input, but with incorrect token:

```bash
curl -X POST https://localhost:3000/chat/simple \
  -H "Content-Type: application/json" \
  -d '{
    "id": "SESSION_ID",
    "input": { "type": "message", "role": "user", "content": "Hello, I'm Bob, how are you?" },
    "token": "xxx"
  }'
```

You got 401, access denied error, as the token is incorrect.


## Studio

`curl` is great, but it's not the most user-friendly way to test an agent, especially for non-technical users. That's why we've built the Studio.

Open `http://localhost:1989` in the browser. You should already see the sessions we created via curl.

// screenshot

### Custom components

Studio allows you to provide your own components for any part of the experience.

Below is `agentview.config.tsx` with custom components for our `simple_chat` agent:

```typescript highlight={14,25,34,38-42}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              role: z.literal("assistant"),
              type: z.literal("message"),
              content: z.any(),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/chat/simple", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
    // other agents...
  ]
```

`displayComponent` is a React component responsible for rendering session item. By default it just shows a block with JSON data.

`inputComponent` is a React component responsible for rendering the input field. AgnetView has a concept of "playground session", which are test sessions that can be created by any team member to play with the agent. You create a playground session by clicking on "Create Session" button in Studio. When you're the owner of the playground session, AgentView will display the `inputComponent` at the bottom so that you can send messages to the agent.

### Collaboration

One of the key features of AgentView is collaboration. It should be easy to discuss Agent outputs, mention stakeholders, domain experts etc. You get powerful collaboration features out of the box:

[video]

## Expand the agent with tools

So far `my_super_agent` was very simple. Let's create a more advanced  example. We're gonna build a weather agent, that is capable of calling `weather_tool` for checking weather in given location.

To show the flexibility of AgnetView, let's use AgentSDK instead of pure Responses API for a change:

```typescript
const weatherAgent = new Agent({
  name: 'Weather Assistant',
  model: 'gpt-5-mini',
  modelSettings: {
    reasoning: { effort: 'medium', summary: 'auto' }
  },
  instructions: 'You are a helpful general-purposeassistant. You have super skill of checking the weather for any location.',
  tools: [
    tool({
      name: 'weather_tool',
      description: 'Get weather information for a location using wttr.in',
      parameters: z.object({
        location: z.string().describe('The city name to get weather for'),
      }),
      execute: async ({ location }) => {
        const response = await fetch(`https://wttr.in/${encodeURIComponent(location)}?format=j2`);
        if (!response.ok) {
          return { error: 'Failed to fetch weather data' };
        }
        return await response.json();
      },
    })
  ],
});

app.post('/agentview/weather_agent/run', async (c) => {
  const { history, input } = parseBody(await c.req.json());

  const result = await run(weatherAgent, [...history, input]);

  return c.json({
    manifest,
    items: result.output
  })
})
```

And let's configure it in `agentview.config.tsx`:

```typescript
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    // ...
    {
      name: "weather_chat",
      url: "http://127.0.0.1:3000/agentview/weather_chat/run",
      run: {
        input: {
          schema: {
            type: "message",
            role: "user",
            content: z.string(),
          },
          displayComponent: ({ value }) => <UserMessage value={value.content} />,
          inputComponent: (props) => <UserMessageInput {...props} submit={(val) => props.submit({ content: val, type: "message", role: "user" })} />
        },
        steps: [
          {
            schema: {
              type: "reasoning",
            },
            displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.content[0]?.text} variant="muted" />,
          },
          {
            schema: {
              type: "function_call",
              name: "weather_tool",
              callId: z.string().meta({ callId: true })
            },
            displayComponent: ({ value }) => <BaseItem title="Weather Tool" value={"Checking weather in: " + JSON.parse(value.arguments).location + "..."} variant="muted" />,
            callResult: {
              schema: {
                type: "function_call_result",
                callId: z.string().meta({ callId: true })
              },
              displayComponent: ({ value }) => <WeatherComponent value={value} />
            }
          },
        ],
        output: {
          schema: {
            role: "assistant",
            type: "message",
            content: z.any(),
          },
          displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />,
        }
      }
    }
})
```

As you can see we added `steps` property in our agent definition. `steps` are all the items that go in a run after `input` and before. Most commonly it's reasoning or tool calls, but it could be handoffs in multi-agent system or actually any custom object that we need to store or display.

As you can see we use `callResult` [to finish]

## Custom Scores

You might have noticed that each message can have Like / Don't Like button. This is a built in score added to every output object. Collecting feedback from users is very important and giving feedback should be as easy as possible to urge domain experts / business stakeholders to leave it.

[ quick score example with multi-select! ]

## Next steps

Learn more about foundation, start with Architecture Overview.

