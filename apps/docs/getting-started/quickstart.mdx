---
title: "Quick Start"
description: "Start building with AgentView in minutes"
---

### Create a project

Start by creating AgentView project:

```bash
npm create agentview@latest my-agentview-project
```

This will install example project in `my-agentview-project/` dir. Go to the project:

```
cd my-agentview-project
```

The root directory of the project has a following structure:
1. `studio/` - Studio React app
2. `agent-python/` - demo Agent Endpoint written in Python + FastAPI
3. `agent-typescript/` - demo Agent Endpoint written in TS + Hono
4. `docker-compose.yml` - since there's no cloud yet, you'll need to set up AgentView Server via docker-compose.

Depending on preference how you want to write AI code you can use either `ai-python/` or `agent-typescript/`. You'll need `studio/` in both cases.

### Run AgentView Server

<Note>AgentView is in beta, so for now you have to self-host the server. We're working on the cloud service, keep an eye on updates!</Note>

To run AgentView server locally you need to install it via docker compose. Just run:

```bash
docker compose up -d
```

Visit `http://localhost:1990/api/status` to see if the server is running. If you get 200 response with `{ "status": "ok", ... }` it means it's all good.

AgentView server exposes AgentView API, which is used by Studio and your apps. 


### Install Studio

Before we continue, let's install and run the studio:

```bash
cd studio
npm install
npm run dev
```

Now go to the `localhost:1989` URL and register as the first admin user.

### Generate API Key

Go to `Settings > API Keys` and grab your personal API key.

### Configure your first agent

The most important file in the AgentView ecosystem is `agentview.config.tsx`. It lives in your Studio project (`studio/agentview.config.tsx`), but it's automatically synced with the AgentView Server.

Let's take a look at it:

```typescript
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
    // other agents...
  ]
```

In this file we defined an agent called `simple_chat` with a single run type:
- Each run in AgentView is just an array of JSON objects.
- Each run starts with an input item (`input`), which is usually a user message.
- Then goes any number of items in between input and output are called `steps`, in this example there's only one type of step - reasoning, but it could be tool calls, server tools, handoffs to other agents in multi-agent systems, etc.
- The last item of the run is the output item (`output`), which is usually an assistant message.

Each item comes with a schema defined with Zod, used for validation and data integrity. The schemas in this example are compatible with OpenAI Responses API item schemas.

`apiBaseUrl` is the location of AgentView Server.

`inputComponent` and `displayComponent` define how the input and output will be displayed in the Studio, we'll cover them later in this section.

### Your Agent Endpoint

When you build an AI agent you have to create a HTTP endpoint that takes user message and generates AI responses. We call this endpoint "Agent Endpoint".

With AgentView you can write your Agent Endpoint in any language or framework you want.

The example Agent Endpoint in Typescript is in `agent-typescript`. Let's run it:

```
cd agent-typescript
npm install
npm run dev
```

Your Agent Endpoint server should be running at `localhost:3000`.

Let's take a look at `src/index.ts`:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';
import { cors } from 'hono/cors';

const app = new Hono();
const client = new OpenAI()

const av = new AgentView({
  apiUrl: 'http://localhost:1990',
  apiKey: process.env.AGENTVIEW_API_KEY!
})

app.use('*', cors({
  origin: ['http://localhost:1989'],
  credentials: true,
}))

app.post('/simple_chat', async (c) => {
  const { id, token, input } = await c.req.json();

  // Create a new user or authenticate if token exists.
  const endUser = token ? 
    await av.getEndUser({ token }) : 
    await av.createEndUser();

  // Create new session or fetch existing one and authorize user's access to the session.
  const session = id ?
    await av.as(endUser).getSession({ id }) : 
    await av.as(endUser).createSession({ agent: "simple_chat" });

  // Create a new run
  // 1. session is now locked - no more runs can be started until this one finishes.
  // 2. will error if session version is semver-incompatible.
  const run = await av.createRun({ 
    sessionId: session.id, 
    items: [input], 
    version: "0.0.1"
  });

  let response : Awaited<ReturnType<typeof client.responses.create>>;

  try {
    // Here you write your stateless AI agent logic.
    response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: {
        effort: "low",
        summary: "detailed"
      },
      // session.items has all the previous items from the session
      input: [...session.items, input]
    });

  } catch (error) {

    // Mark run as failed and save error message
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }

  // Mark run as completed and save output items
  await av.updateRun({
    id: run.id,
    status: "completed",
    items: response.output
  });


  return c.json({
    id: session.id,
    output: response.output,
    token: endUser.token,
  })
})

// Errors from AgentView SDK are ready to be returned via HTTP with correct status code and body.
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

As you can see it's a simple Hono HTTP server exposing a single stateful AI endpoint `POST /simple_chat`:
1. The AI logic is made with Responses API.
2. AgentView SDK handles sessions, session state, users, authorization, persistence, errors, etc. 

#### Test your agent

Call your Agent Endpoint to initiate a new conversation:

```bash
curl -X POST --json '{ "input": { "type": "message", "role": "user", "content": "Hey, my name is Bob." } }' http://localhost:3000/simple_chat
```

You should get a response in a following JSON format:

```ts
{
  "id": "SESSION_ID",
  "output": [ /* output items */],
  "token": "USER_TOKEN"
}
```

Let's continue the thread by sending new message (insert `SESSION_ID` and `USER_TOKEN` from the previous response):

```bash
curl -X POST --json '{
    "id": "SESSION_ID",
    "input": {"type": "message", "role": "user", "content": "Hello, what was my name again?"},
    "token": "USER_TOKEN"
  }' http://localhost:3000/simple_chat
```

You should get a response which shows that the agent remembers your name. AgentView correctly stores the conversation history and remembers the context of the conversation.

Let's send an incorrect input:

```bash
curl -i -X POST --json '{ "input": { "type": "message", "role": "user", "content": 100 } }' http://localhost:3000/simple_chat
```

This triggers `422` error, as the input is not a string. AgentView handles the validation and provides a correct HTTP status code.

## Studio

Open `http://localhost:1989` in the browser to open the Studio. Go to `Playground > Private`. At the top you should see the sessions we just created via curl.

You can already comment on the output, mention other team members, like/dislike the response, etc.

### Custom components

Let's get back to `agentview.config.tsx` and highlight `displayComponent` and `inputComponent` for our `simple_chat` agent:

```typescript highlight={14,25,37,41-45}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
  ]
```

`displayComponent` is a React component responsible for rendering session item. You can play around with it to see how it works. If you set it to `null`, the item will not be hidden. If you remove `displayComponent` completely, you'll see the JSON data.

`inputComponent` is responsible for rendering the input field. It allows users in the Studio to send messages to the agent to play around. `inputComponent` is displayed only for your own Playground Sessions. Production sessions or Playground Sessions created by other users will not have the input field. You can create a new Playground Session by clicking on "Create Session" at the top of the sidebar.

The goal of the AgentView is to make the Studio as customizable as possible. There's much more possible:
- custom domain-specific scoring components
- add custom display properties in the header for sessions and runs
- custom pages
- custom session cards


## Next steps

Learn more about foundation, start with Architecture Overview.

