---
title: "Quick Start"
description: "Start building with AgentView in minutes"
---

This guide will walk through setting up your first agent with AgentView. Along the way, you'll learn more about the concepts that are fundamental to using the SDK in your own projects.

### Create a project

Start by creating AgentView project:

```bash
npm create agentview@latest my-agentview-project
```

This will install example project in `my-agentview-project/` dir. Go to the project:

```
cd my-agentview-project
```

The root directory of the project has a following structure:
1. `studio/` - data viewer React app
2. `agent-python/` - demo Agent Endpoint written in Python + FastAPI
3. `agent-typescript/` - demo Agent Endpoint written in TS + Hono
4. `docker-compose.yml` - since there's no cloud yet, you'll need to set up AgentView Server via docker-compose.

Depending on preference how you want to write AI code you can use either `ai-python/` or `agent-typescript/`. You'll need `studio/` in both cases.

### Run AgentView Server

<Note>AgentView is in beta, so for now you have to self-host the server. We're working on the cloud service, keep an eye on updates!</Note>

To run AgentView server locally you need to install it via docker compose. Just run:

```bash
docker compose up -d
```

Visit `http://localhost:1990/api/status` to see if the server is running. If you get 200 response with `{ "status": "ok", ... }` it means it's all good.

AgentView server exposes AgentView API, which is used by Studio and your apps. 


### Install Studio

Before we continue, let's install and run the studio:

```bash
cd studio
npm install
npm run dev
```

Now go to the `localhost:1989` URL and register as the first admin user.

### Generate API Key

Go to `Settings > API Keys` and grab your personal API key.

### Configure your first agent

The most important file in the AgentView ecosystem is `agentview.config.tsx`. It lives in your Studio project (`studio/agentview.config.tsx`), but it's automatically synced with the AgentView Server.

Let's take a look at it:

```typescript
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
    // other agents...
  ]
```

In this file we defined a simple agent called `simple_chat`. It has one run type with input, output and reasoning step determined by Zod schemas.

`apiBaseUrl` is the location of AgentView Server.

`inputComponent` and `displayComponent` define how the input and output will be displayed in the Studio, we'll cover them later.


### Your Agent Endpoint

When you build an AI agent you have to create a HTTP endpoint that takes user message and generates AI responses. We call this endpoint "Agent Endpoint".

With AgentView you can write your Agent Endpoint in any language or framework you want. AgentView helps you with storing and retrieving sessions and runs, error handling, versioning and managing session lifecycle.

The example Agent Endpoint in Typescript is in `agent-typescript`. Let's run it:

```
cd agent-typescript
npm install
npm run dev
```

Your Agent Endpoint server should be running at `localhost:3000`.

Let's take a look at `src/index.ts`:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';
import { cors } from 'hono/cors';

const app = new Hono();
const client = new OpenAI()
const av = new AgentView({
  apiUrl: 'http://localhost:1990',
  apiKey: process.env.AGENTVIEW_API_KEY!
})

app.use('*', cors({
  origin: ['http://localhost:1989'],
  credentials: true,
}))

// beautiful error handling
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});

app.post('/simple_chat', async (c) => {
  const { id, token, input } = await c.req.json();

  const endUser = token ? 
    await av.getEndUser({ token }) : 
    await av.createEndUser();

  const session = id ?
    await av.as(endUser).getSession({ id }) : 
    await av.as(endUser).createSession({ agent: "simple_chat" });

  const run = await av.createRun({ 
    sessionId: session.id, 
    items: [input], 
    version: "0.0.1"
  });

  let response : Awaited<ReturnType<typeof client.responses.create>>;

  try {
    // Your stateless AI agent logic goes here
    response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: {
        effort: "low",
        summary: "detailed"
      },
      input: [...session.history, input]
    });

  } catch (error) {
    await av.updateRun({
      id: run.id,
      status: "failed",
      failReason: {
        message: (error as Error).message,
      }
    });

    throw error;
  }

  await av.updateRun({
    id: run.id,
    status: "completed",
    items: response.output
  });

  return c.json({
    id: session.id,
    output: response.output,
    token: endUser.token,
  })
})

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

It's a simple Hono HTTP server with a single endpoint `POST /simple_chat`. 

In this example your AI logic is a simple call to OpenAI Responses API:

```typescript    
    response = await client.responses.create({
      model: "gpt-5-nano",
      reasoning: {
        effort: "low",
        summary: "detailed"
      },
      input: [...session.history, input]
    });
```

In practice it could be any framework or your choice, AgentView stays completely agnostic in this regard.

AgentView handles everything **around** your AI logic:
- authenticates and creates end users
- fetches existing session or creates a new one, authorizes user's access to the session
- creates a run, which locks the session for the duration of the run (new calls for this session while run is in progress will fail)
- `session.history` provides the conversation history required by the AI logic
- validates whether the run version is compatible with the initial session version
- stores the response items in the session history, or error message for failed runs
- validates all the items against the schemas from the agent config

All errors from AgentView SDK come with status code and body, so that you can easily redirect it directly to the user as HTTP response:

```typescript
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json({ ...error.details, message: error.message }, error.statusCode as any);
  }
  throw error;
});
```

The goal is so that you focus on AI logic and not on the scaffolding.

### Test your agent

Call your Agent Endpoint to initiate a new conversation:

```bash
curl -X POST --json '{ "input": { "type": "message", "role": "user", "content": "Hey, my name is Bob." } }' http://localhost:3000/simple_chat
```

You should get a response in a following JSON format:

```ts
{
  "id": "SESSION_ID",
  "output": [ /* output items */],
  "token": "USER_TOKEN"
}
```

Let's continue the thread by sending new message

```bash
curl -X POST --json '{
    "id": "SESSION_ID",
    "input": {"type": "message", "role": "user", "content": "Hello, what was my name again?"},
    "token": "USER_TOKEN"
  }' http://localhost:3000/simple_chat
```

You should get a response which shows that the agent remembers your name. AgentView correctly stores the conversation history and remembers the context of the conversation.

### Errors

Let's send an incorrect input:

```bash
curl -i -X POST --json '{ "input": { "type": "message", "role": "user", "content": 100 } }' http://localhost:3000/simple_chat
```

This triggers `422` error, as the input is not a string. Let's send a correct input, but with incorrect token:

```bash
curl -i -X POST --json '{
    "id": "SESSION_ID",
    "input": {"type": "message", "role": "user", "content": "Hello, what was my name again?"},
    "token": "surely_incorrect_token"
  }' http://localhost:3000/simple_chat
```

You should get `404` - user not found.

## Studio

`curl` is great, but it's not the most user-friendly way to test an agent, especially for non-technical users. That's why we've built the Studio.

Open `http://localhost:1989` in the browser. Go to `Playground > Private`. At the top you should see the sessions we just created via curl.

### Custom components

Studio allows you to provide your own components for any part of the experience. 

Below is `agentview.config.tsx` with custom components for our `simple_chat` highlighted:

```typescript highlight={14,25,37,41-45}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ value }) => <UserMessage value={value.content} />,
          },
          steps: [
            {
              schema: z.object({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }).loose(),
              displayComponent: ({ value }) => <BaseItem title="Thinking" value={value.summary[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ value }) => <AssistantMessage value={value.content[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    },
    // other agents...
  ]
```

`displayComponent` is a React component responsible for rendering session item. You can play around with it to see how it works. If you set it to `null`, the item will not be hidden. If you remove `displayComponent` completely, you'll see the JSON data.

`inputComponent` is responsible for rendering the input field. It allows users in the Studio to send messages to the agent to play around. `inputComponent` is displayed only for your own Playground Sessions. Production sessions or Playground Sessions created by other users will not have the input field. You can create a new Playground Session by clicking on "Create Session" at the top of the sidebar.

### Collaboration

One of the key features of AgentView is collaboration. It should be easy to discuss Agent outputs, mention stakeholders, domain experts etc. You get powerful collaboration features out of the box:

[video]


### Custom Scores

You might have noticed that each message can have Like / Don't Like button. This is a built in score added to every output object. Collecting feedback from users is very important and giving feedback should be as easy as possible to urge domain experts / business stakeholders to leave it.

[ quick score example with multi-select! ]

## Next steps

Learn more about foundation, start with Architecture Overview.

