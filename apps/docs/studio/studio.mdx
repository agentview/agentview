---
title: "Studio"
description: "\"Look at your data\" in a beautiful way."
---

## Overview

AgentView comes with a Studio, a powerful and collaborative data viewer for your agents. It's designed with following principles in mind:
- **focus on non-technical users** - we want studio to provide Notion-like simplicity to encourage business stakeholders and subject-matter experts to look at the data and leave feedback.
- **collaboration** - we want studio to be a collaborative environment, where all the users can see the data and leave feedback.
- **customisation** - every domain is different, which requires different way of displaying data.

AgentView Studio is designed to be extremely customisable. You can provide custom components to any part of the experience. It's shipped as a React package so that it's possible.

## Session Items

The most common customisation is providing a custom view for session items. You can set it via `displayComponent` property of the session item. It's just a React component:

{ /* <prompt>
  - copy apps/examples/typescript-basic/agentview.config.tsx file into following snippet
  - highlight `displayComponent` lines (and entire components that are values of `displayComponent` property)
</prompt> */ }

```tsx highlight={19,30-37,49}
import { z } from "zod";
import { defineConfig } from "agentview";
import { AssistantMessage, ItemCard, ItemCardMarkdown, ItemCardTitle, UserMessage, UserMessageInput } from "@agentview/studio/components/session-item";
import { Brain } from "lucide-react";

export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

{ /* <prompt>
  - look up the properties type of `displayComponent` property
  - create a table "Prop" | "Description" | "Type"
  - descriptions shoudl be very short in this case. Item "content of your session item", session: current session object, etc.
</prompt> */ }

Here are `displayComponent` properties:

| Prop | Description | Type |
|------|-------------|------|
| `item` | Content of the session item | `any` |
| `session` | Current session object | `Session` |
| `run` | Current run object | `Run` |
| `resultItem` | Only for tool calls, content of the tool call result | `any` |


#### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema the component won't be displayed**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.

#### Hiding items

You can hide items by setting `displayComponent` to `null`.

#### Tool calls

Tool calls come in pairs: call and result. Also, if you use paralell tool calls, the call and result blocks might not be consecutive. We find the best UX to display then with a single component.

You can define tools via `callResult` property (read more here: [items validation](/concepts/items-validation#tool-calls)).

{ /* <prompt>
  - copy apps/examples/typescript-weather-agent/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - leave the step with function call intact, but comment out (with "// ..." or alike) input, output, other steps, etc... make it short and focused on the function call.
</prompt> */ }

```tsx
export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      runs: [
        {
          input: { /* ... */ },
          output: { /* ... */ },
          steps: [
            // ...
            {
              schema: z.looseObject({
                type: z.literal("function_call"),
                name: z.literal("weather_tool"),
                callId: z.string().meta({ callId: true }),
              }),
              callResult: {
                schema: z.looseObject({
                  type: z.literal("function_call_result"),
                  callId: z.string().meta({ callId: true }),
                })
              },
              displayComponent: ({ item, resultItem }) => { /* ... */ }
            }
          ]
        }
      ]
    }
  ]
})
```

When the tool call is done, both `item` and `resultItem` are set. When call is in progress, `resultItem` is `undefined`.


## Session Input

AgentView allows the members of your organisation to play around with your agent. In order to make it possible, your users must have a component via which they can provide input to your agent and start a new run.

You can set it via `inputComponent` property of the agent:

{ /* <prompt>
  - copy apps/examples/typescript-basic/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - leave `input`, `output`, and `inputComponent`, collapse the rest (with "// ..." or alike)
  - highlight `inputComponent` line (and entire component that is its value)
</prompt> */ }

```tsx highlight={24-28}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            // ...
          ],
          output: {
            // ...
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
})
```

The job of `inputComponent` is to submit a request to your Agent Endpoint, which should trigger a new run. Please keep in mind that *Studio doesn't listen to the response from your Agent* (it might be your custom format). It only displays live changes based on the data you sent to AgentView via `av.createRun` or `av.updateRun` calls. For example, if your Agent Endpoint is streaming each token, but it only calls `av.updateRun` at the end of the stream, then AgentView will see update only at the end of the stream.

`<UserMessageInput />` is simple component from AgentView Design System that displays a text input, send and cancel buttons. You can provide your custom one whenever you need to.

Here are `inputComponent` properties: 

| Prop | Description | Type |
|------|-------------|------|
| `session` | Current session object | `Session` |
| `token` | A user token | `string` |
| `submit` | A thin wrapper on top of native browser `fetch`, that manages state and simplifies code. | `(url: string, body: Record<string, any>, init?: RequestInit) => Promise<Response>` |
| `cancel` | If you use `submit`, it cancels the request properly | `() => void` |
| `isRunning` | If you use `submit`, it properly handles information whether the component should be disabled | `boolean` |


#### `submit` function

`submit` is a thin wrapper on top of native browser `fetch` function that reduces a lot of boilerplate code:
- sets `POST` method and `Content-Type: application/json` header
- accepts `body` second parameter as a JSON
- if you call `cancel` it properly handles cancellation
- properly computes `isRunning` based on session and request state

`submit` returns a `Response` object like fetch, and its 3rd parameter `init?` is the same as you would pass to `fetch` function (second param).

## Session Header

Each session comes with a header that displays session properties. You can easily set your own by providing `displayProperties` property:

```typescript
export default defineConfig({
  agents: [
    {
      displayProperties: [
        {
          title: "User Location",
          value: ({ session }) => <strong>{ session.metadata?.userLocation }</strong>
        }
      ],
      // ...
    }
  ]
})
```

## Run View

Below each run there's a footer with "Run" button. It displays run properties. You can customize it by providing `displayProperties` property:

```tsx
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
          {
            displayProperties: [
              {
                title: "Trace ID",
                value: ({ run }) => <strong>{ run.metadata?.traceId }</strong>
              }
            ],
            // ...
          }
        }
      ]
    }
  ]
})
```

## Scores 

TODO:
- how to add scores and custom views

## Comments

TODO:
- enable / disabled comments

## New Session Form

TODO

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )


