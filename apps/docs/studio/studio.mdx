---
title: "Studio"
description: "\"Look at your data\" in a beautiful way."
---

AgentView comes with a Studio, a powerful and collaborative data viewer for your agents. It's designed with following principles in mind:
- **focus on non-technical users** - we want studio to provide Notion-like simplicity to encourage business stakeholders and subject-matter experts to look at the data and leave feedback.
- **collaboration** - we want studio to be a collaborative environment, where all the users can see the data and leave feedback.
- **customisation** - every domain is different, which requires different way of displaying data.

AgentView Studio is designed to be extremely customisable. You can provide custom components to any part of the experience. It's shipped as a React package so that it's possible.

## Customizing Session View 

Let's dig into how to customize how your sessions look in the Studio.

### Session Items

First and most important customisation is providing a custom view for session items. You can do this by providing a custom component to `displayComponent` property of the session item:

```tsx highlight={18,29,41}
import { z } from "zod";
import { defineConfig } from "agentview";
import { UserMessage, AssistantMessage, UserMessageInput, BaseItem } from "@agentview/studio/components/session-item";

export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage value={item} />,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => <BaseItem title="Thinking" value={item[0]?.text ?? "Hidden reasoning summary."} variant="muted" />,
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage value={item[0]?.text} />
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

#### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema it shows this as an error**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.


#### Tool calls

Tool calls come in pairs: call and result. In case of paralell tool calls blocks might not be consecutive. We find the best UX to always show them together:
- when call is in progress, display the info
- when results come, display call + result in a single block and hide the call block.

```tsx
export default defineConfig({
    agents: [
        {
            name: "my_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true }),
                                    weatherString: z.string()
                                },
                            },
                            displayComponent: ({ data, resultData }) => {
                                if (!resultData) { // call in progress
                                    return <StepBlock title="Weather Tool">Checking weather...</StepBlock>
                                }
                                else {
                                    return <StepBlock title="Weather Tool">{resultData.weatherString}</StepBlock>
                                }
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

You can disable this behaviour by setting `displaySeparately: true`.

```tsx
{
    schema: {
        type: "function_call",
        name: "weather_tool",
        callId: z.string().meta({ callId: true })
    },
    displayComponent: // separate call block

    callResult: {
        schema: {
            type: "function_call_result",
            callId: z.string().meta({ callId: true }),
            weatherString: z.string()
        },
        dispayComponent: // separate result block
    },

    displaySeparately: true
},
```

## Input Forms - creating test environment

AgentView allows the members of your organisation to play around with your agent. All you need to do is provide an `inputComponent` and make it submit a request to your chat endpoint.

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        },
                        displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            },
                            displayComponent: ({ data }) => <StepBlock title="Thinking">{ data.content }</StepBlock>
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        },                            
                        displayComponent: ({ data }) => <AssistantMessage>{ data.content }</AssistantMessage>
                    }
                }
            ],
            inputComponent: ({ isLoading, cancel, submit, token, session }) => <UserMessageInput
                onSubmit={(value) => {
                    submit("https://localhost:3000/chat", { input: { type: "message", role: "user", content: value }, id: session.id, token })
                }} 
                isLoading={isLoading}
                onCancel={cancel}
            />
        }
    ]
})
```

`inputComponent` is a React Component with following props:
- `session: Session` - current session (you can access `session.lastRun`, `session.history`, `session.runs`, etc.)
- `userToken: string` - an authorization token for your AI endpoint
- `submit(url: string, value?: Record<string, any>, fetchOptions?: RequestInit) => Promise` - a thin wrapper on top of native browser `fetch`, that manages state and simplifies code.
- `cancel()` - if you use `submit`, it cancels the request properly
- `isLoading: bool` - if you use `submit`, it's a proper `isLoading` state

### `submit`

You can use `fetch`, however `submit` handles quite a lot of things:
- it sends request to `POST`
- sets a header `Content-Type: application/json`
- injects `userToken` and `sessionId` into the body. The body is `{ userToken, sessionId, input: your_input }`
- connects `AbortController` to properly cancel the connections and update the app state. Makes `cancel` function easily available.
- computes `isLoading` based on session and request state

### Clearing the form

You should clear your form after calling `submit`. The right moment is not Promise success (it might happen after the end of run), but after the new run is successfully created. It means your endpoint acknowledged the input and sent it propertly to AgentView. Here's a simple hack

```tsx
{,
    // ...
    inputComponent: ({ isLoading, cancel, submit }) => {
        useOnRunStart(() => {
            // clear your form
        })

        return <div>{ /* ... */ }</div>
    }
}

```

## Scores 

Every Session Item can be commented and scored. You can notice that by default each user can leave "Like" reaction to every output item.

TODO:
- disabled likes
- add custom score

## Comments

TODO:
- enable / disabled comments


## Customizing Session Header

You can add session items easily. Just use `displayedProperties`:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            metadata: {
                product_id: z.string()
            },
            displayProperties: [
                {
                    title: "Product",
                    value: ({ session }) => <strong>{ session.metadata.product_id}</strong> // can be anything
                }
            ],
            // ...
        }
    ]
})
```

// TODO: full custom header

## Session Form

// TODO: describe how to create new session with properties.


## Customzing Run Preview

You can set Run Preview custom properties in similar fashion:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            metadata: {
                product_id: z.string()
            },
            runs: [
                {
                    // other run props...
                    displayProperties: [
                        {
                            title: "Custom Property",
                            value: ({ session, run }) => <strong>{ run.metadata.someValue}</strong> // can be anything
                        }
                    ],
                }
            ]
            // ...
        }
    ]
})
```

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )


