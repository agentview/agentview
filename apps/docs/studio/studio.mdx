---
title: "Studio"
description: "\"Look at your data\" in a beautiful way."
---

AgentView comes with a Studio, a powerful and collaborative data viewer for your agents. It's designed with following principles in mind:
- **focus on non-technical users** - we want studio to provide Notion-like simplicity to encourage business stakeholders and subject-matter experts to look at the data and leave feedback.
- **collaboration** - we want studio to be a collaborative environment, where all the users can see the data and leave feedback.
- **customisation** - every domain is different, which requires different way of displaying data.

AgentView Studio is designed to be extremely customisable. You can provide custom components to any part of the experience. It's shipped as a React package so that it's possible.

## Customizing Session View 

Let's dig into how to customize how your sessions look in the Studio.

### Items

First and most important customisation is providing a custom view for session items. You can do this by providing a custom component to `displayComponent` property of the session item:

```tsx highlight={19,30-36,49}
import { z } from "zod";
import { defineConfig } from "agentview";
import { AssistantMessage, ItemCard, ItemCardMarkdown, ItemCardTitle, UserMessage, UserMessageInput } from "@agentview/studio/components/session-item";
import { Brain } from "lucide-react";

export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

The `item` property is the content of the session item.

#### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema the component won't be displayed**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.


#### Tool calls

Tool calls come in pairs: call and result. Also, if you use paralell tool calls, the call and result blocks might not be consecutive. We find the best UX to display then with a single component.

You can define tools via `callResult` property (read more here: [items validation](/concepts/items-validation#tool-calls)).



```tsx
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: /* ... */,
          output: /* ... */,
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("function_call"),
                name: z.literal("weather_tool"),
                callId: z.string().meta({ callId: true }),
              }),
              callResult: {
                schema: z.looseObject({
                  type: z.literal("function_call_result"),
                  callId: z.string().meta({ callId: true }),
                })
              },
              displayComponent: ({ item, resultItem }) => { /* ... */ }
            }
            // ...
          ]
        }
      ]
    }
  ]
})
```

When the tool call is done, both `item` and `resultItem` are set. When call is in progress, `resultItem` is `undefined`.


### Input

AgentView allows the members of your organisation to play around with your agent. All you need to do is provide an `inputComponent` and make it submit a request to your chat endpoint.

```tsx highlight={26-32}
export default defineConfig({
  // ...
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          input: {
            schema: {
              type: "message",
              role: "user",
              content: z.string(),
            },
            displayComponent: ({ item }) => <UserMessage>{ item.content }</UserMessage>
          },
          output: {
            schema: {
              type: "message",
              role: "assistant",
              content: z.string(),
            },                            
            displayComponent: ({ item }) => <AssistantMessage>{ item.content }</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(value) => {
          submit("http://localhost:3000/simple_chat", { input: { type: "message", role: "user", content: value } })
        }} 
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
})
```

`inputComponent` is a React Component with following props:
- `session: Session` - current session object
- `token: string` - a user token
- `submit(url: string, fetchOptions?: RequestInit & { input?: any }) => Promise` - a thin wrapper on top of native browser `fetch`, that manages state and simplifies code.
- `cancel()` - if you use `submit`, it cancels the request properly
- `isRunning: bool` - if you use `submit`, it properly handles information whether the component should be disabled 

#### `submit`

You can use `fetch`, however `submit` handles quite a lot of things:
- it sends request to `POST`
- sets a header `Content-Type: application/json`
- injects `token` and `id` into the body. The body is `{ id, token, input: your_input }`
- connects `AbortController` to properly cancel the connections and update the app state. Makes `cancel` function easily available.
- computes `isRunning` based on session and request state

### Header properties

Each session comes with a header that displays session properties. You can easily set your own by providing `displayProperties` property:

```typescript
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
        {
          // ...
        }
      ],
      displayProperties: [
        {
          title: "Product",
          value: ({ session }) => <strong>{ session.metadata.product_id}</strong>
        }
      ]
    }
  ]
})
```

### Run properties

Below each run there's a footer with "Run" button. It displays run properties. You can customize it by providing `displayProperties` property:

```tsx
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
          {
            // ...
            displayProperties: [
              {
                title: "Trace ID",
                value: ({ run }) => <strong>{ run.metadata?.traceId}</strong>
              }
            ]
          }
        }
      ]
    }
  ]
})
```

## Scores 

TODO:
- how to add scores and custom views

## Comments

TODO:
- enable / disabled comments

## New Session Form

TODO

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )


