---
title: "Studio"
description: "\"Look at your data\" in a beautiful way."
---

## Overview

AgentView comes with a Studio, a powerful and collaborative data viewer for your agents. It's designed with following principles in mind:
- **focus on non-technical users** - we want studio to provide Notion-like simplicity to encourage business stakeholders and subject-matter experts to look at the data and leave feedback.
- **collaboration** - we want studio to be a collaborative environment, where all the users can see the data and leave feedback.
- **customisation** - every domain is different, which requires different way of displaying data.

AgentView Studio is designed to be extremely customisable. You can provide custom components to any part of the experience. It's shipped as a React package so that it's possible.

## Session Items

The most common customisation is providing a custom view for session items. You can set it via `displayComponent` property of the session item. It's just a React component:

{ /* <prompt>
  - copy apps/examples/typescript-basic/agentview.config.tsx file into following snippet
  - highlight `displayComponent` lines (and entire components that are values of `displayComponent` property)
</prompt> */ }

```tsx highlight={19,30-37,49}
import { z } from "zod";
import { defineConfig } from "agentview";
import { AssistantMessage, ItemCard, ItemCardMarkdown, ItemCardTitle, UserMessage, UserMessageInput } from "@agentview/studio/components/session-item";
import { Brain } from "lucide-react";

export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            {
              schema: z.looseObject({
                type: z.literal("reasoning"),
                summary: z.array(z.object({
                  type: z.literal("summary_text"),
                  text: z.string(),
                })),
              }),
              displayComponent: ({ item }) => {
                return (
                  <ItemCard size="sm" variant="fill">
                    <ItemCardTitle><Brain /> Thinking</ItemCardTitle>
                    <ItemCardMarkdown text={item.summary?.map((s: any) => s?.text ?? "").join("\n\n") ?? "Hidden reasoning summary."} />
                  </ItemCard>
                );
              }
            }
          ],
          output: {
            schema: z.looseObject({
              type: z.literal("message"),
              role: z.literal("assistant"),
              content: z.array(z.object({
                type: z.literal("output_text"),
                text: z.string(),
              })),
            }),
            displayComponent: ({ item }) => <AssistantMessage>{item.content.map((c: any) => c?.text ?? "").join("\n\n")}</AssistantMessage>
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
});
```

{ /* <prompt>
  - look up the properties type of `displayComponent` property
  - create a table "Prop" | "Description" | "Type"
  - descriptions shoudl be very short in this case. Item "content of your session item", session: current session object, etc.
</prompt> */ }

Here are `displayComponent` properties:

| Prop | Description | Type |
|------|-------------|------|
| `item` | Content of the session item | `any` |
| `session` | Current session object | `Session` |
| `run` | Current run object | `Run` |
| `resultItem` | Only for tool calls, content of the tool call result | `any` |


#### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema the component won't be displayed**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.

#### Hiding items

You can hide items by setting `displayComponent` to `null`.

#### Tool calls

Tool calls come in pairs: call and result. Also, if you use paralell tool calls, the call and result blocks might not be consecutive. We find the best UX to display then with a single component.

You can define tools via `callResult` property (read more here: [items validation](/concepts/items-validation#tool-calls)).

{ /* <prompt>
  - copy apps/examples/typescript-weather-agent/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - leave the step with function call intact, but comment out (with "// ..." or alike) input, output, other steps, etc... make it short and focused on the function call.
</prompt> */ }

```tsx
export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      runs: [
        {
          input: { /* ... */ },
          output: { /* ... */ },
          steps: [
            // ...
            {
              schema: z.looseObject({
                type: z.literal("function_call"),
                name: z.literal("weather_tool"),
                callId: z.string().meta({ callId: true }),
              }),
              callResult: {
                schema: z.looseObject({
                  type: z.literal("function_call_result"),
                  callId: z.string().meta({ callId: true }),
                })
              },
              displayComponent: ({ item, resultItem }) => { /* ... */ }
            }
          ]
        }
      ]
    }
  ]
})
```

When the tool call is done, both `item` and `resultItem` are set. When call is in progress, `resultItem` is `undefined`.


## Session Input

AgentView allows the members of your organisation to play around with your agent. In order to make it possible, your users must have a component via which they can provide input to your agent and start a new run.

You can set it via `inputComponent` property of the agent:

{ /* <prompt>
  - copy apps/examples/typescript-basic/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - leave `input`, `output`, and `inputComponent`, collapse the rest (with "// ..." or alike)
  - highlight `inputComponent` line (and entire component that is its value)
</prompt> */ }

```tsx highlight={24-28}
export default defineConfig({
  apiBaseUrl: "http://localhost:1990",
  agents: [
    {
      name: "simple_chat",
      runs: [
        {
          input: {
            schema: z.object({
              type: z.literal("message"),
              role: z.literal("user"),
              content: z.string(),
            }),
            displayComponent: ({ item }) => <UserMessage>{item.content}</UserMessage>,
          },
          steps: [
            // ...
          ],
          output: {
            // ...
          }
        }
      ],
      inputComponent: ({ submit, cancel, isRunning }) => <UserMessageInput
        onSubmit={(val) => submit("http://localhost:3000/simple_chat", { input: { content: val, type: "message", role: "user" } })}
        onCancel={cancel}
        isRunning={isRunning}
      />
    }
  ]
})
```

The job of `inputComponent` is to submit a request to your Agent Endpoint, which should trigger a new run. Please keep in mind that *Studio doesn't listen to the response from your Agent* (it might be your custom format). It only displays live changes based on the data you sent to AgentView via `av.createRun` or `av.updateRun` calls. For example, if your Agent Endpoint is streaming each token, but it only calls `av.updateRun` at the end of the stream, then AgentView will see update only at the end of the stream.

`<UserMessageInput />` is simple component from AgentView Design System that displays a text input, send and cancel buttons. You can provide your custom one whenever you need to.

Here are `inputComponent` properties: 

| Prop | Description | Type |
|------|-------------|------|
| `session` | Current session object | `Session` |
| `token` | A user token | `string` |
| `submit` | A thin wrapper on top of native browser `fetch`, that manages state and simplifies code. | `(url: string, body: Record<string, any>, init?: RequestInit) => Promise<Response>` |
| `cancel` | If you use `submit`, it cancels the request properly | `() => void` |
| `isRunning` | If you use `submit`, it properly handles information whether the component should be disabled | `boolean` |


#### `submit` function

`submit` is a thin wrapper on top of native browser `fetch` function that reduces a lot of boilerplate code:
- sets `POST` method and `Content-Type: application/json` header
- accepts `body` second parameter as a JSON
- if you call `cancel` it properly handles cancellation
- properly computes `isRunning` based on session and request state

`submit` returns a `Response` object like fetch, and its 3rd parameter `init?` is the same as you would pass to `fetch` function (second param).

## Session Header

Each session comes with a header that displays session properties. You can easily set your own by providing `displayProperties` property:

```typescript
export default defineConfig({
  agents: [
    {
      displayProperties: [
        {
          title: "User Location",
          value: ({ session }) => <strong>{ session.metadata?.userLocation }</strong>
        }
      ],
      // ...
    }
  ]
})
```

## Run View

Below each run there's a footer with "Run" button. It displays run properties. You can customize it by providing `displayProperties` property:

```tsx
export default defineConfig({
  agents: [
    {
      name: "my_agent",
      runs: [
          {
            displayProperties: [
              {
                title: "Input tokens",
                value: ({ run }) => run?.metadata?.usage?.inputTokens
              },
              {
                title: "Output tokens",
                value: ({ run }) => run?.metadata?.usage?.outputTokens
              }
            ]
            // ...
          }
        }
      ]
    }
  ]
})
```

## New Session Form

Members of your organisation can create new playground sessions by clicking on "Create Session" button. However, your session might require some metadata to be properly created.

You can provide a custom form by setting `newSessionComponent` property:

{ /* <prompt>
  - copy apps/examples/typescript-weather-agent/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - remove almost everything, leave only `name`, `metadata` and `newSessionComponent` properties so that user understands what's going on.
</prompt> */ }

```tsx
export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      metadata: {
        userLocation: z.string()
      },
      newSessionComponent: ({ submit, isRunning }) => {
        return <div>
          <Input type="text" placeholder="Enter your location" />
          <Button type="submit" disabled={isRunning}>Create Session</Button>
        </div>
      }
    }
  ]
})
```

`submit` function takes 2 properties:

| Prop | Description | Type |
|------|-------------|------|
| `submit` | A function creates new session with proper metadata | `(values: { metadata?: Record<string, any> }) => void` |
| `isRunning` | `true` if session is being created | `boolean` |

When you call it and session is created successfully it will redirect user to the session page.


## Scores 

Each Session Item can have custom scores. Each score is just a name, schema and custom components for input and display.

{ /* <prompt>
  - copy apps/examples/typescript-weather-agent/agentview.config.tsx file into following snippet
  - remove imports, leave only `export default defineConfig({...})` block
  - add only the import of score types (multiSelect, select)
  - leave only the output section with scores definitions.
  - highlight `scores`
</prompt> */ }

```tsx
import { select, multiSelect } from "@agentview/studio";

export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      runs: [
        {
          output: {
            schema: ...,
            scores: [
              select({
                name: "forecast_accuracy",
                title: "Forecast Accuracy",
                options: [
                  { value: "accurate", label: "Accurate", color: Colors.green },
                  { value: "partially_accurate", label: "Partially Accurate", color: Colors.yellow },
                  { value: "inaccurate", label: "Inaccurate", color: Colors.red },
                ]
              }),
              multiSelect({
                name: "style",
                title: "Style",
                options: [
                  { value: "too-long", label: "Too long", color: Colors.red },    
                  { value: "too-brief", label: "Too brief", color: Colors.yellow },
                  { value: "confusing", label: "Confusing", color: Colors.red },
                  { value: "overly-technical", label: "Overly technical", color: Colors.red },
                ]
              })
            ]
          }
        }
      ]
    }
  ]
})
```

`select` and `multiSelect` are handy helpers to build basic scores faster.

You can build your own scores with custom schemas and custom components. Each score is actually just an object with following properties:

| Prop | Description | Type |
|------|-------------|------|
| `name` | The name of the score | `string` |
| `schema` | The schema of the score | `z.ZodSchema` |
| `inputComponent` | The component to render the input in Scores dialog | `ControlComponent` |
| `displayComponent` | The component to render the display in Comments section | `React.Component<{ value: any }>` |
| `actionBarComponent` | The component to render the action bar below the item display component | `ControlComponent` |

### Like Component

Each `output` component by default gets a "Like" score. It's a simple boolean score that is displayed in the action bar below the item display component.

You can disable it by setting `disableLike` property to `true`:

```tsx
export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      runs: [
        {
          output: {
            schema: ...,
            disableLike: true
          }
        }
      ]
    }
  ]
})
```

If you want to add like to other components than output, you can use `like()` helper:

```tsx
import { like } from "@agentview/studio";

export default defineConfig({
  agents: [
    {
      name: "weather-chat",
      runs: [
        {
          steps: [
            {
              schema: ...,
              scores: [
                like()
              ]
            }
          }
        }
      ]
    }
  ]
})
```

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )


