# Studio


## Displaying Session Items

By default, the AgentView Studio will just show JSON representation of the items.

You can provide a custom view for each session item in your agent by using `displayComponent` property:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        },
                        displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            },
                            displayComponent: ({ data }) => <StepBlock title="Thinking">{ data.content }</StepBlock>
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        },                            
                        displayComponent: ({ data }) => <AssistantMessage>{ data.content }</AssistantMessage>
                    }
                }
            ]
        },
        // ...
    ]
})
```

### Tool calls

Tool calls come in pairs: call and result. In case of paralell tool calls blocks might not be consecutive. We find the best UX to always show them together:
- when call is in progress, display the info
- when results come, display call + result in a single block and hide the call block.

```tsx
export default defineConfig({
    agents: [
        {
            name: "my_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true }),
                                    weatherString: z.string()
                                },
                            },
                            displayComponent: ({ data, resultData }) => {
                                if (!resultData) { // call in progress
                                    return <StepBlock title="Weather Tool">Checking weather...</StepBlock>
                                }
                                else {
                                    return <StepBlock title="Weather Tool">{resultData.weatherString}</StepBlock>
                                }
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

You can disable this behaviour by setting `displaySeparately: true`.

```tsx
{
    schema: {
        type: "function_call",
        name: "weather_tool",
        callId: z.string().meta({ callId: true })
    },
    displayComponent: // separate call block

    callResult: {
        schema: {
            type: "function_call_result",
            callId: z.string().meta({ callId: true }),
            weatherString: z.string()
        },
        dispayComponent: // separate result block
    },

    displaySeparately: true
},
```

### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema it shows this as an error**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.

## Input Forms - creating test environment

AgentView allows the members of your organisation to play around with your agent. All you need to do is provide an `inputComponent` and make it submit a request to your chat endpoint.

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        },
                        displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            },
                            displayComponent: ({ data }) => <StepBlock title="Thinking">{ data.content }</StepBlock>
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        },                            
                        displayComponent: ({ data }) => <AssistantMessage>{ data.content }</AssistantMessage>
                    }
                }
            ],
            inputComponent: ({ isLoading, cancel, submit, token, session }) => <UserMessageInput
                onSubmit={(value) => {
                    submit("https://localhost:3000/chat", { input: { type: "message", role: "user", content: value }, id: session.id, token })
                }} 
                isLoading={isLoading}
                onCancel={cancel}
            />
        }
    ]
})
```

`inputComponent` is a React Component with following props:
- `session: Session` - current session (you can access `session.lastRun`, `session.history`, `session.runs`, etc.)
- `userToken: string` - an authorization token for your AI endpoint
- `submit(url: string, value?: Record<string, any>, fetchOptions?: RequestInit) => Promise` - a thin wrapper on top of native browser `fetch`, that manages state and simplifies code.
- `cancel()` - if you use `submit`, it cancels the request properly
- `isLoading: bool` - if you use `submit`, it's a proper `isLoading` state

### `submit`

You can use `fetch`, however `submit` handles quite a lot of things:
- it sends request to `POST`
- sets a header `Content-Type: application/json`
- injects `userToken` and `sessionId` into the body. The body is `{ userToken, sessionId, input: your_input }`
- connects `AbortController` to properly cancel the connections and update the app state. Makes `cancel` function easily available.
- computes `isLoading` based on session and request state

### Clearing the form

You should clear your form after calling `submit`. The right moment is not Promise success (it might happen after the end of run), but after the new run is successfully created. It means your endpoint acknowledged the input and sent it propertly to AgentView. Here's a simple hack

```tsx
{,
    // ...
    inputComponent: ({ isLoading, cancel, submit }) => {
        useOnRunStart(() => {
            // clear your form
        })

        return <div>{ /* ... */ }</div>
    }
}

```

## Scores 

Every Session Item can be commented and scored. You can notice that by default each user can leave "Like" reaction to every output item.

TODO:
- disabled likes
- add custom score

## Comments

TODO:
- enable / disabled comments


## Customizing Session Header

You can add session items easily. Just use `displayedProperties`:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            metadata: {
                product_id: z.string()
            },
            displayProperties: [
                {
                    title: "Product",
                    value: ({ session }) => <strong>{ session.metadata.product_id}</strong> // can be anything
                }
            ],
            // ...
        }
    ]
})
```

// TODO: full custom header

## Session Form

// TODO: describe how to create new session with properties.


## Customzing Run Preview

You can set Run Preview custom properties in similar fashion:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "my_agent",
            metadata: {
                product_id: z.string()
            },
            runs: [
                {
                    // other run props...
                    displayProperties: [
                        {
                            title: "Custom Property",
                            value: ({ session, run }) => <strong>{ run.metadata.someValue}</strong> // can be anything
                        }
                    ],
                }
            ]
            // ...
        }
    ]
})
```

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )


