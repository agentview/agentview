# Architecture overview

## AgentView parts

AgentView consists of 2 main parts: Server and Studio. All the configuration is managed in code via `agentview.config.tsx` file.

### Server

**Server** is a backend part. It is capable of storing all your agent sessions state, validation and resumability, managing users authentication and memories, and a lot more that your agent needs. It communicates with outer world via API called AgentView API.

For now, you must set it up locally via `docker-compose.yml`, we'll ship Cloud version soon.

### Studio

The **Studio** is a powerful and customisable session viewer. It's shipped as a React package. When you look at our example from *Getting Started* you'll see that Studio is a Vite app run in this way:


```ts
import "./styles.css";
import { renderStudio } from "agentview";
import agentviewConfig from "./agentview.config";

renderStudio(
    document.getElementById("agentview"), 
    agentviewConfig
);
```

Here are some most important traits:

- collaborative - invite users, comment, get notifications on activity
- extremely customisable - provide custom components to any part of experience. It's shipped as a React package so that it's possible.
- test environment - users can test agent in AgentView
- private, shared, production sessions are separated
- add custom pages, make it a control panel of your agent

### Configuration

All the AgentView configuration is in `agentview.config.tsx` file. This file lives in Studio project and must be provided to Studio in `renderStudio(...)`.

All the agent definition information (mostly schemas) is sent to the AgentView Server. Thanks to this Server can do proper validation and prevent incorrect data getting into your system.

In order to make this connection work you set `server` property in `agentview.config.tsx` file:

```typescript
export default defineConfig({
    apiUrl: process.env.AGENTVIEW_API_URL,
    // ...
})
```

Now when you run `npm run dev` in your Studio project, each time `agentview.config.tsx` is changed, it's gonna be synchronised with the Server.

## Your App Architecture

The typical architecture looks like this:

[image: schema]

Your app stays being your app, you can build it in any way you want, in a language or framework of your choice. The only difference is that your AI logic can be stateless and you can send the agent state to AgentView.

The only endpoint you **must** provide is `/chat` endpoint. The purpose of this endpoint is take user input and generate AI responses. For the rest of the things your users can talk to AgentView API directly from the browser (read-only access).

The Data Viewer is a separate app that talks to AgentView API directly. 




# API

## Agent 

The core object in AgentView is an agent. Agent represents an entity that is responsible for doing one job (for example being a shopping assistant).

Here's the simplest possible definition of an agent:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent"
        }
    ]
});
```

The Agent definition above is enough to create a session and add a bunch of items to it.

```ts
import { AgentView } from "agentview";

const av = new AgentView({
    apiUrl: "http://localhost:3000",
    apiKey: "AGENTVIEW_PERSONAL_SECRET_KEY",    
    agent: "very_simple_agent",
    version: "0.0.1"
});

const session = await av.createSession()

await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" },
        { type: "reasoning", content: "Hmm, this is a very complex question..." },
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    sessionId: session.id
    status: "complete",
})

const updatedSession = await av.getSession({ id: session.id })

console.log(updatedSession.history)
```

If you run this script in a terminal you should see following output object printed:

```bash
[
    { type: "message", role: "user", content: "Hello, I'm Bob" },
    { type: "reasoning", content: "Hmm, this is a very complex question..." },
    { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
]
```

You can also open the Studio to see a new unstyled Session in your Personal Playground.

## Sessions

Session represents a multi-turn conversation between user and an agent. It's kind of like the instance of an agent.

### Create a session

```typescript
const session = await av.createSession()
```

### Session Items

The core part of each session state is an ordered list of Session Items, or just Items. Items can be added via [Runs](#) (we explain Runs later in this chapter).

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" },
        { type: "reasoning", content: "Hmm, this is a very complex question..." },
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    sessionId: session.id
    status: "complete",
})
```

Item is a totally arbitrary object that represents that something happened in the history of our session and it needs to be stored for consistent continuation:
- user or assistant messages
- reasoning blocks
- tools (function calls, MCP, server tools)
- handoffs to other agents in multi-agent systems
- any custom block

Items are **incremental**. It means that each time you update run with `items` they'll be **appended** at to the list. Removing items is not possible.

Each Item is displayed as a separate block in Studio, can have its own custom component, can be commentable, can have its custom scores, feedback etc.

It's worth highlighting that Item in AgnetView is just a JSON, it can be *anything*. AgentView goal is to be as unopinionated as possible and therefore doesn't force you into any pre-defined message formats. This allows to make it really framework-agnostic. For example, it's trivial to just send items from AgentsSDK, Responses API, AI SDK, LangChain, without any trouble.

#### Squashing items into array

// TO-DO!!!

### Session `state`

Sometimes it's hard to represent a session state just with array of Items. For example, durign the course of the session you might create session memories, or additional artifacts needed for thread summarisation (to prevent context overflow). You might want to store them between runs, but, it's unnatural to keep them as Items.

For that purpose AgentView introduced the concept of the state. State is totally arbitrary object bounded to a session available via `session.state`.

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob. I have terrible acne, help me." },
        { type: "reasoning", content: "Thinking on the response..." },
        { type: "message", role: "assistant", content: "Use our Anti-Acne Super Cream, it will heal you." }
    ],
    state: {
        userName: "Bob",
        skincareProfile: "has terrible acne"
    }
    sessionId: session.id
    status: "complete"
})

const session = await av.getSession({ id })
console.log(session.state) // { userName: "Bob", skincareProfile: "..." }
```

You always get access to the *last* instance of the state. However, AgentView tracks the full history of the state changes so that you can copy the session up to a particular moment in time and continue it with different scenario.

### Reading session

```typescript
const session = await av.getSession({ 
    id: "session_id"
})

console.log(session.history) // session items
console.log(session.state) // session state
console.log(session.lastRun) // last run
console.log(session.lastRun.status) // last run status
console.log(session.runs) // all runs
```

### Session Metadata

Sessions can have custom metadata. AgentView aims to be as flexible as possible, that's why every object can be extended custom metadata.

Imagine you're building a shopping assistant which can run on the product page of e-commerce website. In that case each session must have `product_id` assigned.

Let's update our agent config:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            }
        }
    ]
});
```

`metadata` is an object with so called "metafields". Each metafield has a key (name) and it's Zod schema.

Now when we create a new session we **must** provide `product_id` (since it's not `.optional()`):

```ts
const session = await av.createSession({ 
    metadata: { 
        product_id: "beautiful_pants_123",
    }
})
```

If we tried to call `createSession` without providing `product_id` the `createSession` function would throw an error.

By default, if metafield is **not** defined in metadata, it's allowed to add it (no validation). If you want to override it:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string(),
            },
            allowUnknownMetadata: false
        }
    ]
});
```

## Runs

You add items to a session via runs. Run is a special object helping in managing lifecycle of the session.

Run represents a single turn of the conversation. It starts with a user action, usually just a user message, an input item. Then the any number of items might be produced, and in the end the output item must be added, which ends the run. Run in more complex systems will usually consist of multiple calls to the LLMs, tool calls, etc.

Here's how to create a run with a user message input message.

```ts
const run = await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
})

console.log(run.status) // in_progress
```

### Run status

The run `status` can be `in_progress`, `complete` or `failed`. After the run is created it automatically has `in_progress` value. When the run is `in_progress`, the session won't accept any new runs. Below, the second `av.createRun` will result in an exception:

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
})

await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
}) // throws AgentViewError, you can have only one in_progress run at a time!
```

### Adding items

You can call `av.updateRun` as many times as you want to keep adding items.

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "reasoning", content: "Thinking..." },
        { type: "reasoning", content: "Thinking even harder..." }
    ]
})
```

 We highly recommend using streaming and sending data to AgentView as soon as they appear. It allows for better retry / resume logic later. 

 ### Ending Run

 If the run finished successfully, just set the status to `complete`:

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    status: "complete"
})
```

It's possible that you agent might encounter an error during a run. You can set mark a run as failed easily:

```ts
const run = await av.updateRun({ 
    id: run.id,
    status: "failed",
    failReason: {
        message: "LLM model error.",
        details: ...
    }
})
```

When the run is finished (`failed` or `complete`), you can't change its status nor add items anymore. 

### Retrying failed sessions

If the last session run was failed, you can still create a new run. If you do it, the last failed run items will be removed from the history and the items from your new run will be appended to the last successful run (the one before the failed one):

Retry logic with keeping only the user message:

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: [session.lastRun.items[0]],
        sessionId
    })
}
```

Resume (all the items from previous failed run preserved):

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: session.lastRun.items,
        sessionId
    })
}
```

### Removing items

You can't remove items from the session. The core foundation behind AgentView is that whenever you send an item to a client (or agentview), the end user saw it. If end user saw it, then anyone using AgentView Studio should also be able to see it, exactly as user did. 

### Run metadata

Similary to sessions, runs can be extended with custom metadata. It's helpful when you want to store usage data, trace id for observability platform link, etc.

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    metadata: {
        trace_id: "TRACE_ID", // for example Langfuse trace id
        cost: "0.15"
    }
})
```

Similar to sessions, by default unknown keys are allowed. You can change this behaviour by provide schema and settings `allowUnk

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    metadata: {
                        trace_id: z.string()
                    },
                    allowUnknownMetadata: false,
                    // ...
                }
            ]
        }
    ]
});
```

### Long running jobs

The run will automatically be set as failed after 1 minute of inactivity. If your agent is long running you can send heartbeat to tell AgentView Server that the run is still processing:

```ts
await av.ping({ runId: "RUN_ID" })
```

## Items Validation

The default settings of AgentView are very relaxed not to overload you with annoying errors during development. However, you can provide schemas to provide stronger validation.

### Input and Output

The following code says that `very_simple_agent` has a single run.

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ]
        }
        // ...
    ]
})
```

Here's what's happens now:
1. When you create a run with `av.createRun`, the first item in `items` array is treated as "input".
2. AgentView scans all the available runs from the agent config and matches the `input`.
3. If it found a matching run, all the validation will be done according this run settings. So in this case, it's gonna make sure that the last item in items array (output) matches the `output` schema.


```ts
// Correct, output matches input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", role: "assistant", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
})

// Throws, incorrect output for a given input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", content: "Hello Bob, how are you?" } // no "role"
    ],
    status: "complete",
})
```

By default, if AgnetView can't find a run based on input item, it will fallback to "unknown run" which allows for any item shape. So this is still possible:

```ts
// Can't match any run -> unknown run -> allow
await av.createRun({
    items: [
        { type: "blah" }
        { type: "message", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
})
```

You can disable this behaviour:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                // ...
            ],
            allowUnknownRuns: false
        }
        // ...
    ]
})
```

Now, an input item of new run **must** match at least one input from the runs array.

### Steps

For now we just validated input and output, which is first and and last items of a run. The items between input and output are called "steps". You can make sure steps conform to the schemas you provide:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            }
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ],
            allowUnknownSteps: false
        },
        // ...
    ]
})
```

In this example only the reasoning steps with string content are allowed. Please keep in mind you must set `allowUnknownSteps` to `false`. Without it, even if no matching stpe is found, AgentView will treat the step as unknown and allow it to be added.

### Tool calls

Tool calls are pretty special in a sense that there always come in pairs. There's a tool call item and tool result items, usually related to each other by tool call id.

AgentView allows to represent this in the schema:

```typescript
export default defineConfig({
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true })
                                },
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

In this scenario AgentView will make sure that every weather function call has appropriate result.

### Strict validation

By default the items are matched loosely, which means that unknown keys will be treated as a match and saved. You can force strict matching by setting `allowUnknownItemKeys` flag to `false`:

```typescript
export default defineConfig({
    agents: [
        {
            name: "my_super_agent",
            runs: [
                // ...
            ],            
            allowUnknownItemKeys: false
        }
    ]
})
```

## Versioning

As you update your agent over time, users may attempt to continue sessions that were created with a **previous** version of your agent. Maintaining compatibility between versions can be challenging, and sometimes it's better to prevent continuation rather than risk incompatibility. AgentView handles this scenario through versioning.

Each run in AgentView must have a version attached. Provide the current version of your agent using the `version` parameter in the `AgentView` constructor:

```ts
const av = new AgentView({
    agent: "my_agent",
    version: "0.1.1"
})
```

AgentView uses semantic versioning to determine compatibility. Sessions can only be continued with patch version increases (e.g., `0.2.5` â†’ `0.2.6`). Minor or major version changes break compatibility and will prevent session continuation.

### Example

Consider a session where the first run was created with version `0.2.5`. If you upgrade your agent to version `0.2.6`, the session can be continued with a new run because patch version increases are considered backward-compatible according to semantic versioning. It's your responsibility to ensure that patch version updates maintain backward compatibility. Minor changes to the system prompt are a good example of a backward-compatible change that would warrant a patch version increase.

However, if the first run of your session was `0.2.5`, AgentView will throw an error if the next run has:
- A smaller patch version (e.g., `0.2.4`)
- A different minor version (e.g., `0.3.0`)
- A different major version (e.g., `1.0.0`) 



## Error Handling

As you can see, AgentView does a lot to make sure your app state is always correct. It handles items and metadata validation and orchestrates the session lifecycle thanks to a run state.

Any time an error occurs, AgnetView will throw an exception which is an instance of `AgentViewError`. It has `body` and `statusCode` propreties so that it's trivial to just redirect it directly to the user as HTTP responses from your endpoint:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';

const app = new Hono();
const client = new OpenAI()

const av = new AgentView({
    agent: "my_simple_agent",
    version: "0.2.1"
})

app.post('/chat', async (c) => {
  const { sessionId, input, endUserToken } = await c.req.json();

  // create or get session
  const session = sessionId ?
    await av.sessions.get({ id: sessionId, endUserToken }):
    await av.sessions.create({ agent: "my_simple_agent" })

  // create run
  const run = await av.createRun({ input, sessionId: session.id });

  // generate response
  const response = await client.responses.create({
    model: "gpt-5-nano",
    input: [...session.history, input]
  });

  // push items and close run (the last item of output is assistant message)
  await av.updateRun({
    id: run.id
    items: response.output,
  })

  return c.json({
    output: response.output,
    sessionId: session.id,
    token: session.endUser.token
  })
})

// Handle AgentViewError
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json(error.body, error.status);
  }
});

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

You can now call from your browser:

```ts

```


## Users and Authentication

Every session in AgentView is connected with a User. This is very helpful because we might have multiple sessions connected with teh same user which allows for memory, etc.

When you create a session without specifically pointing at any user, a new anonymous user will be created under the hood.

```ts
const session = await av.createSession({ agent: "my_simple_agent" });

console.log(session.user) // { id: "...", externalId: "...", token: "..." }
```

User object has 3 properties:
- `id` - AgentView id
- `externalId` - unique user id from host platform (for example Shopify), so that you can easily match users
- `token` - user's authentication token

The `token` should be send over to the client's browser so that you can use AgnetView API on the client side. 

### Creating Users

You can create user manually using `av.createEndUser`

```ts
const user1 = await av.createEndUser({ externalId: "..." }) // with external id

const user2 = await av.createEndUser() // without external id
```

### Fetching Users

You can fetch user by using id, external id or token:

```ts
await av.getEndUser({ agent, endUserId: "user_id" })
await av.getEndUser({ agent, endUserExternalId: "user_external_id" })
await av.getEndUser({ agent, endUserToken: "user_token" })
```

### Creating Sessions for specific user

You can create a session for a particular user:

```ts
await av.createSession({ agent, endUserId: "user_id" })
await av.createSession({ agent, endUserExternalId: "user_external_id" })
await av.createSession({ agent, endUserToken: "user_token" })
```


### Client-Side Authentication

The AgentView API key is secret and shouldn't be sent to the browser (or any other client-side app).

However, you can still use AgnetView API directly on the client-side if you have user token: 

```ts
const av = new AgentView({
    apiUrl: "http://localhost:3000",
    endUserToken: "user_token"
});
```

Such instance of `AgentView` has read-only access to this user's sessions, memories, etc.


# Studio


## Displaying Session Items

By default, the AgnetView Studio will just show JSON representation of the items.

You can provide a custom view for each session item in your agent by using `displayComponent` property:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        },
                        displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            },
                            displayComponent: ({ data }) => <StepBlock title="Thinking">{ data.content }</StepBlock>
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        },                            
                        displayComponent: ({ data }) => <AssistantMessage>{ data.content }</AssistantMessage>
                    }
                }
            ]
        },
        // ...
    ]
})
```

### Tool calls

Tool calls come in pairs: call and result. In case of paralell tool calls blocks might not be consecutive. We find the best UX to always show them together:
- when call is in progress, display the info
- when results come, display call + result in a single block and hide the call block.

```tsx
export default defineConfig({
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true }),
                                    weatherString: z.string()
                                },
                            },
                            displayComponent: ({ data, resultData }) => {
                                if (!resultData) { // call in progress
                                    return <StepBlock title="Weather Tool">Checking weather...</StepBlock>
                                }
                                else {
                                    return <StepBlock title="Weather Tool">{resultData.weatherString}</StepBlock>
                                }
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

You can disable this behaviour by setting `displaySeparately: true`.

```tsx
{
    schema: {
        type: "function_call",
        name: "weather_tool",
        callId: z.string().meta({ callId: true })
    },
    displayComponent: // separate call block

    callResult: {
        schema: {
            type: "function_call_result",
            callId: z.string().meta({ callId: true }),
            weatherString: z.string()
        },
        dispayComponent: // separate result block
    },

    displaySeparately: true
},
```

### Matching items

AgentView finds the right `displayComponent` for a session item by matching the provided schemas. **If the item matches more than 1 schema it shows this as an error**.

This implies that your items should be uniquely discriminatable. You should be able to discriminate between them by schemas. It's usually done by `type`, but for AI apps it's a bit more tricky, for example function calls are discriminated by `name`, type for all tools are the same.

## Input Forms - creating test environment

AgentView allows the members of your organisation to play around with your agent. All you need to do is provide an `inputComponent` and make it submit a request to your chat endpoint.

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        },
                        displayComponent: ({ data }) => <UserMessage>{data.content}</UserMessage>
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            },
                            displayComponent: ({ data }) => <StepBlock title="Thinking">{ data.content }</StepBlock>
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        },                            
                        displayComponent: ({ data }) => <AssistantMessage>{ data.content }</AssistantMessage>
                    }
                }
            ],
            inputComponent: ({ isLoading, cancel, submit }) => <UserMessageInput
                onSubmit={(value) => {
                    submit("https://localhost:3000/chat", { input: { content: value } })
                }} 
                isLoading={isLoading}
                onCancel={cancel}
            />
        }
    ]
})
```

`inputComponent` is a React Component with following props:
- `session: Session` - current session (you can access `session.lastRun`, `session.history`, `session.runs`, etc.)
- `userToken: string` - an authorization token for your AI endpoint
- `submit(url: string, value?: Record<string, any>, fetchOptions?: RequestInit) => Promise` - a thin wrapper on top of native browser `fetch`, that manages state and simplifies code.
- `cancel()` - if you use `submit`, it cancels the request properly
- `isLoading: bool` - if you use `submit`, it's a proper `isLoading` state

### `submit`

You can use `fetch`, however `submit` handles quite a lot of things:
- it sends request to `POST`
- sets a header `Content-Type: application/json`
- injects `userToken` and `sessionId` into the body. The body is `{ userToken, sessionId, input: your_input }`
- connects `AbortController` to properly cancel the connections and update the app state. Makes `cancel` function easily available.
- computes `isLoading` based on session and request state

### Clearing the form

You should clear your form after calling `submit`. The right moment is not Promise success (it might happen after the end of run), but after the new run is successfully created. It means your endpoint acknowledged the input and sent it propertly to AgentView. Here's a simple hack

```tsx
{,
    // ...
    inputComponent: ({ isLoading, cancel, submit }) => {
        useOnRunStart(() => {
            // clear your form
        })

        return <div>{ /* ... */ }</div>
    }
}

```

## Scores 

Every Session Item can be commented and scored. You can notice that by default each user can leave "Like" reaction to every output item.

TODO:
- disabled likes
- add custom score

## Comments

TODO:
- enable / disabled comments


## Customizing Session Header

You can add session items easily. Just use `displayedProperties`:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            },
            displayProperties: [
                {
                    title: "Product",
                    value: ({ session }) => <strong>{ session.metadata.product_id}</strong> // can be anything
                }
            ],
            // ...
        }
    ]
})
```

// TODO: full custom header

## Session Form

// TODO: describe how to create new session with properties.


## Customzing Run Preview

You can set Run Preview custom properties in similar fashion:

```tsx
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            },
            runs: [
                {
                    // other run props...
                    displayProperties: [
                        {
                            title: "Custom Property",
                            value: ({ session, run }) => <strong>{ run.metadata.someValue}</strong> // can be anything
                        }
                    ],
                }
            ]
            // ...
        }
    ]
})
```

## Custom Pages

TODO:
- describe "scopes" (loggedOut, agent, )






<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

# -- notes --

MISSING PARTS:
- some parts of UI
- some simple StoryBook (really simple one pls)







Basic without any scaffolding:

```tsx
const inputComponent = ({ session, userToken }) => {
    const abortController = useRef(null)

    return <UserMessageInput
        onSubmit={(value) => {
            abortController.current = new AbortController();

            fetch("https://localhost:3000/chat", {
                headers: {
                    'Content-Type': 'application/json',
                },
                method: 'POST',
                body: JSON.stringify({
                    input: { content: value },
                    sessionId: session.id
                    userToken
                }),
                signal: abortController.current.signal
            }).catch(() => {

            }).finally(() => {
                abortController.current = null;
            })
        }} 
        onCancel={() => {
            abortController.abort();  
        }}
        isLoading={abortController.current || session.lastRun?.status === "in_progress"}
    />
}
```

This is a fucking nightmare.

Alternative:

```tsx
const inputComponent = ({ isLoading, cancel, submit }) => <UserMessageInput
    onSubmit={(value) => {
        submit("https://localhost:3000/chat", { content: value })
    }} 
    isLoading={isLoading}
    onCancel={cancel}
/>
```

Props:
- submit
- isLoading
- onCancel
- 

What if we have attachments???
- from the perspective of this API it's exactly the same. `value` should have correct file URLs.
- 