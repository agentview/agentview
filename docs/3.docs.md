# Architecture overview

## AgentView parts

AgentView consists of 2 main parts: Server and Studio. All the configuration is managed in code via `agentview.config.tsx` file.

### Server

**Server** is a backend part. It is capable of storing all your agent sessions state, validation and resumability, managing users authentication and memories, and a lot more that your agent needs. It communicates with outer world via API called AgentView API.

For now, you must set it up locally via `docker-compose.yml`, we'll ship Cloud version soon.

### Studio

The **Studio** is a powerful and customisable session viewer. It's shipped as a React package. When you look at our example from *Getting Started* you'll see that Studio is a Vite app run in this way:


```ts
import "./styles.css";
import { renderStudio } from "agentview";
import agentviewConfig from "./agentview.config";

renderStudio(
    document.getElementById("agentview"), 
    agentviewConfig
);
```

Since it's React package is super easy to provide your own custom React components. 

### Configuration

All the AgentView configuration is in `agentview.config.tsx` file. This file lives in Studio project and must be provided to Studio in `renderStudio(...)`.

All the agent definition information (mostly schemas) is sent to the AgentView Server. Thanks to this Server can do proper validation and prevent incorrect data getting into your system.

In order to make this connection work you set `server` property in `agentview.config.tsx` file:

```typescript
export default defineConfig({
    apiUrl: process.env.AGENTVIEW_API_URL,
    // ...
})
```

Now when you run `npm run dev` in your Studio project, each time `agentview.config.tsx` is changed, it's gonna be synchronised with the Server.

## Your App Architecture

The typical architecture looks like this:

[image: schema]

Your app stays being your app, you can build it in any way you want, in a language or framework of your choice. The only difference is that your AI logic can be stateless and you can send the agent state to AgentView.

The only endpoint you **must** provide is `/chat` endpoint. The purpose of this endpoint is take user input and generate AI responses. For the rest of the things your users can talk to AgentView API directly from the browser (read-only access).

The Data Viewer is a separate app that talks to AgentView API directly. 




# API

## Agent 

The core object in AgentView is an agent. Agent represents an entity that is responsible for doing one job (for example being a shopping assistant).

Here's the simplest possible definition of an agent:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent"
        }
    ]
});
```

The Agent definition above is enough to create a session and add a bunch of items to it.

```ts
import { AgentView } from "agentview";

const av = new AgentView({
    apiUrl: "http://localhost:3000",
    apiKey: "AGENTVIEW_PERSONAL_SECRET_KEY"
});

const session = await av.createSession({
    agent: "very_simple_agent"
})

await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" },
        { type: "reasoning", content: "Hmm, this is a very complex question..." },
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    sessionId: session.id
    status: "complete",
    version: "0.0.1"
})

const updatedSession = await av.getSession({ id: session.id })

console.log(updatedSession.history)
```

If you run this script in a terminal you should see following output object printed:

```bash
[
    { type: "message", role: "user", content: "Hello, I'm Bob" },
    { type: "reasoning", content: "Hmm, this is a very complex question..." },
    { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
]
```

You can also open the Studio to see a new unstyled Session in your Personal Playground.

## Sessions

Session represents a multi-turn conversation between user and an agent. It's kind of like the instance of an agent.

### Create a session

```typescript
const session = await av.createSession({ 
    agent: "very_simple_agent"
})
```

### Session Items

The core part of each session state is an ordered list of Session Items, or just Items. Items can be added via [Runs](#) (we explain Runs later in this chapter).

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" },
        { type: "reasoning", content: "Hmm, this is a very complex question..." },
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    sessionId: session.id
    status: "complete",
    version: "0.0.1"
})
```

Item is a totally arbitrary object that represents that something happened in the history of our session and it needs to be stored for consistent continuation:
- user or assistant messages
- reasoning blocks
- tools (function calls, MCP, server tools)
- handoffs to other agents in multi-agent systems
- any custom block

Items are **incremental**. It means that each time you update run with `items` they'll be **appended** at to the list. Removing items is not possible.

Each Item is displayed as a separate block in Studio, can have its own custom component, can be commentable, can have its custom scores, feedback etc.

It's worth highlighting that Item in AgnetView is just a JSON, it can be *anything*. AgentView goal is to be as unopinionated as possible and therefore doesn't force you into any pre-defined message formats. This allows to make it really framework-agnostic. For example, it's trivial to just send items from AgentsSDK, Responses API, AI SDK, LangChain, without any trouble.

#### Squashing items into array

// explain

### Session `state`

Sometimes it's hard to represent a session state just with array of Items. For example, durign the course of the session you might create session memories, or additional artifacts needed for thread summarisation (to prevent context overflow). You might want to store them between runs, but, it's unnatural to keep them as Items.

For that purpose AgentView introduced the concept of the state. State is totally arbitrary object bounded to a session available via `session.state`.

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob. I have terrible acne, help me." },
        { type: "reasoning", content: "Thinking on the response..." },
        { type: "message", role: "assistant", content: "Use our Anti-Acne Super Cream, it will heal you." }
    ],
    state: {
        userName: "Bob",
        skincareProfile: "has terrible acne"
    }
    sessionId: session.id
    status: "complete",
    version: "0.0.1"
})

const session = await av.getSession({ id })
console.log(session.state) // { userName: "Bob", skincareProfile: "..." }
```

You always get access to the *last* instance of the state. However, AgentView tracks the full history of the state changes so that you can copy the session up to a particular moment in time and continue it with different scenario.

### Reading session

```typescript
const session = await av.getSession({ 
    id: "session_id"
})

console.log(session.history) // session items
console.log(session.state) // session state
console.log(session.lastRun) // last run
console.log(session.lastRun.status) // last run status
console.log(session.runs) // all runs
```

### Session Metadata

Sessions can have custom metadata. AgentView aims to be as flexible as possible, that's why every object can be extended custom metadata.

Imagine you're building a shopping assistant which can run on the product page of e-commerce website. In that case each session must have `product_id` assigned.

Let's update our agent config:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            }
        }
    ]
});
```

`metadata` is an object with so called "metafields". Each metafield has a key (name) and it's Zod schema.

Now when we create a new session we **must** provide `product_id` (since it's not `.optional()`):

```ts
const session = await av.createSession({ 
    agent: "very_simple_agent",
    metadata: { 
        product_id: "beautiful_pants_123",
    }
})
```

If we tried to call `createSession` without providing `product_id` the `createSession` function would throw an error.

By default, if metafield is **not** defined in metadata, it's allowed to add it (no validation). If you want to override it:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string(),
            },
            allowUnknownMetadata: false
        }
    ]
});
```

## Runs

You add items to a session via runs. Run is a special object helping in managing lifecycle of the session.

Run represents a single turn of the conversation. It starts with a user action, usually just a user message, an input item. Then the any number of items might be produced, and in the end the output item must be added, which ends the run. Run in more complex systems will usually consist of multiple calls to the LLMs, tool calls, etc.

Here's how to create a run with a user message input message.

```ts
const run = await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version
})

console.log(run.status) // in_progress
```

### Run status

The run `status` can be `in_progress`, `complete` or `failed`. After the run is created it automatically has `in_progress` value. When the run is `in_progress`, the session won't accept any new runs. Below, the second `av.createRun` will result in an exception:

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version
})

await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version
}) // throws AgentViewError, you can have only one in_progress run at a time!
```

### Adding items

You can call `av.updateRun` as many times as you want to keep adding items.

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "reasoning", content: "Thinking..." },
        { type: "reasoning", content: "Thinking even harder..." }
    ]
})
```

 We highly recommend using streaming and sending data to AgentView as soon as they appear. It allows for better retry / resume logic later. 

 ### Ending Run

 If the run finished successfully, just set the status to `complete`:

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    status: "complete"
})
```

It's possible that you agent might encounter an error during a run. You can set mark a run as failed easily:

```ts
const run = await av.updateRun({ 
    id: run.id,
    status: "failed",
    failReason: {
        message: "LLM model error.",
        details: ...
    }
})
```

When the run is finished (`failed` or `complete`), you can't change its status nor add items anymore. 

### Retrying failed sessions

If the last session run was failed, you can still create a new run. If you do it, the last failed run items will be removed from the history and the items from your new run will be appended to the last successful run (the one before the failed one):

Retry logic with keeping only the user message:

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: [session.lastRun.items[0]],
        sessionId,
        version
    })
}
```

Resume (all the items from previous failed run preserved):

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: session.lastRun.items,
        sessionId,
        version
    })
}
```

### Removing items

You can't remove items from the session. The core foundation behind AgentView is that whenever you send an item to a client (or agentview), the end user saw it. If end user saw it, then anyone using AgentView Studio should also be able to see it, exactly as user did. 

### Run metadata

Similary to sessions, runs can be extended with custom metadata. It's helpful when you want to store usage data, trace id for observability platform link, etc.

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    metadata: {
        trace_id: "TRACE_ID", // for example Langfuse trace id
        cost: "0.15"
    }
})
```

Similar to sessions, by default unknown keys are allowed. You can change this behaviour by provide schema and settings `allowUnk

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    metadata: {
                        trace_id: z.string()
                    },
                    allowUnknownMetadata: false,
                    // ...
                }
            ]
        }
    ]
});
```

### Long running jobs

The run will automatically be set as failed after 1 minute of inactivity. If your agent is long running you can send heartbeat to tell AgentView Server that the run is still processing:

```ts
await av.ping({ runId: "RUN_ID" })
```


## Items Validation

The default settings of AgentView are very relaxed not to overload you with annoying errors during development. However, you can provide schemas to provide stronger validation.

### Input and Output

The following code says that `very_simple_agent` has a single run.

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ]
        }
        // ...
    ]
})
```

Here's what's happens now:
1. When you create a run with `av.createRun`, the first item in `items` array is treated as "input".
2. AgentView scans all the available runs from the agent config and matches the `input`.
3. If it found a matching run, all the validation will be done according this run settings. So in this case, it's gonna make sure that the last item in items array (output) matches the `output` schema.


```ts
// Correct, output matches input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", role: "assistant", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
    version
})

// Throws, incorrect output for a given input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", content: "Hello Bob, how are you?" } // no "role"
    ],
    status: "complete",
    version
})
```

By default, if AgnetView can't find a run based on input item, it will fallback to "unknown run" which allows for any item shape. So this is still possible:

```ts
// Can't match any run -> unknown run -> allow
await av.createRun({
    items: [
        { type: "blah" }
        { type: "message", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
    version
})
```

You can disable this behaviour:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                // ...
            ],
            allowUnknownRuns: false
        }
        // ...
    ]
})
```

Now, an input item of new run **must** match at least one input from the runs array.

### Steps

For now we just validated input and output, which is first and and last items of a run. The items between input and output are called "steps". You can make sure steps conform to the schemas you provide:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            }
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ],
            allowUnknownSteps: false
        },
        // ...
    ]
})
```

In this example only the reasoning steps with string content are allowed. Please keep in mind you must set `allowUnknownSteps` to `false`. Without it, even if no matching stpe is found, AgentView will treat the step as unknown and allow it to be added.

### Tool calls

Tool calls are pretty special in a sense that there always come in pairs. There's a tool call item and tool result items, usually related to each other by tool call id.

AgentView allows to represent this in the schema:

```typescript
export default defineConfig({
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true })
                                },
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

In this scenario AgentView will make sure that every weather function call has appropriate result.

### Strict validation

By default the items are matched loosely, which means that unknown keys will be treated as a match and saved. You can force strict matching by setting `allowUnknownItemKeys` flag to `false`:

```typescript
export default defineConfig({
    agents: [
        {
            name: "my_super_agent",
            runs: [
                // ...
            ],            
            allowUnknownItemKeys: false
        }
    ]
})
```


## Error Handling

As you can see, AgentView does a lot to make sure your app state is always correct. It handles items and metadata validation and orchestrates the session lifecycle thanks to a run state.

Any time an error occurs, AgnetView will throw an exception which is an instance of `AgentViewError`. It has `body` and `statusCode` propreties so that it's trivial to just redirect it directly to the user as HTTP responses from your endpoint:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';

const app = new Hono();
const client = new OpenAI()
const av = new AgentView()
const version = "0.2.1"
const agent = "my_simple_agent"

app.post('/chat', async (c) => {
  const { sessionId, input, token } = await c.req.json();

  // create or get session
  const session = sessionId ?
    await av.getSession(sessionId):
    await av.createSession({ agent })

  // create run
  const run = await av.createRun({ input, sessionId: session.id, token, version });

  // generate response
  const response = await client.responses.create({
    model: "gpt-5-nano",
    input: [...session.history, input]
  });

  // push items and close run (the last item of output is assistant message)
  await av.updateRun({
    id: run.id
    items: response.output,
  })

  return c.json({
    output: response.output
  })
})

// Handle AgentViewError
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json(error.body, error.status);
  }
});

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

You can now call from your browser:

```ts

```


## Users and Authentication

Every session in AgentView is connected with a User. This is very helpful because we might have multiple sessions connected with teh same user which allows for memory, etc.

When you create a session without specifically pointing at any user, a new anonymous user will be created under the hood.

```ts
const session = await av.createSession({ agent: "my_simple_agent" });

console.log(session.user) // { id: "...", externalId: "...", token: "..." }
```

User object has 3 properties:
- `id` - AgentView id
- `externalId` - unique user id from host platform (for example Shopify), so that you can easily match users
- `token` - user's authentication token

The `token` should be send over to the client's browser so that you can use AgnetView API on the client side. 

### Creating Users

You can create user manually using `av.createUser`

```ts
const user1 = await av.createUser({ externalId: "..." }) // with external id

const user2 = await av.createUser() // without external id
```

### Fetching Users

You can fetch user by using id, external id or token:

```ts
await av.getUser({ agent, userId: "user_id" })
await av.getUser({ agent, userExternalId: "user_external_id" })
await av.getUser({ agent, userToken: "user_token" })
```

### Creating Sessions for specific user

You can create a session for a particular user:

```ts
await av.createSession({ agent, userId: "user_id" })
await av.createSession({ agent, userExternalId: "user_external_id" })
await av.createSession({ agent, userToken: "user_token" })
```


### Client-Side Authentication

The AgentView API key is secret and shouldn't be sent to the browser (or any other client-side app).

However, you can still use AgnetView API directly on the client-side if you have user token: 

```ts
const av = new AgentView({
    apiUrl: "http://localhost:3000",
    userToken: "user_token"
});
```

Such instance of `AgentView` has read-only access to this user's sessions, memories, etc.






# --- todo ---

1. Message grouping (squash & fuck it for now)
2. Versioning
3. Security âœ…

## Security

What's the model of security? 

1. Public Client (browser)
2. Private Client (server) + API KEY

### Public Client

1. Must run `av.auth()` to get a token.
2. Anonymous logins are possible depending on settings.
3. `av.auth({ id_token })` can also be able to CREATE new user, or not (also based on settings).
4. Has READ access to OWN sessions only (not write!!!, call `/chat` to write).

### Private Client

1. Has all the permissions because of existence of API_KEY.
2. Can create users manually (set external id if necessary).
3. Session without anything creates a new user automatically.
4. When creating a session it can set `{ userId }` to bind it to specific user. If the auth token is INCORRECT 
5. Can set `{ authToken }` to also "find" the user to assign session to.




### Questions

1. Playground permission model - isn't it too much? To analyse.


## Studio: 
- displayProperties
- inputItems
- inputForm (session context)
- scores
