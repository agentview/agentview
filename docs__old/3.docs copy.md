# Architecture overview

AgentView consists of 2 main parts: Server and Studio. All the configuration is managed in code via `agentview.config.tsx` file.

### Server

**Server** is a backend part. It is capable of storing all your agent sessions state, validation and resumability, managing users authentication and memories, and a lot more that your agent needs. It communicates with outer world via API called AgentView API.

For now, you must set it up locally via `docker-compose.yml`, we'll ship Cloud version soon.

### Studio

The **Studio** is a powerful and customisable session viewer. It's shipped as a React package. When you look at our example from *Getting Started* you'll see that Studio is a Vite app run in this way:


```ts
import "./styles.css";
import { renderStudio } from "agentview";
import agentviewConfig from "./agentview.config";

renderStudio(
    document.getElementById("agentview"), 
    agentviewConfig
);
```

Since it's React package is super easy to provide your own custom React components. 

### Configuration

All the AgentView configuration is in `agentview.config.tsx` file. This file lives in Studio project and must be provided to Studio in `renderStudio(...)`.

All the agent definition information (mostly schemas) is sent to the AgentView Server. Thanks to this Server can do proper validation and prevent incorrect data getting into your system.

In order to make this connection work you set `server` property in `agentview.config.tsx` file:

```typescript
export default defineConfig({
    baseUrl: process.env.AGENTVIEW_API_URL,
    // ...
})
```

Now when you run `npm run dev` in your Studio project, each time `agentview.config.tsx` is changed, it's gonna be synchronised with the Server.

# API

### Agent 

The core object in AgentView is an agent. Agent represents an entity that is responsible for doing one job (for example being a shopping assistant).

Here's the simplest possible definition of an agent:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent"
        }
    ]
});
```

This is enough to create a session, add a run with items:

```ts
const av = new AgentView({
    baseUrl: "http://localhost:3000"
});

// Authenticate as an anonymous user
const { token } = await av.auth(); 

// Create session
const session = await av.createSession({
    agent: "very_simple_agent",
    token
})

// Create a run with input item
const run = await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version,
    token,
})

// build an output (here you should call LLM!)
const outputItems = [
    { type: "reasoning", content: "Hmm, this is a very complex question..." }
    { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
]

// add output items and end the run
await av.updateRun({
    id: run.id,
    items: outputItems,
    status: "complete",
    version,
    token,
})

// Fetch session
const updatedSession = await av.getSession({ id: session.id, token })

console.log(updatedSession.history)
/**
 * [
 *  { type: "message", role: "user", content: "Hello, I'm Bob" },
 *  { type: "reasoning", content: "Hmm, this is a very complex question..." },
 *  { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
 * ]
 */

console.log(updatedSession.lastRun.status) // "complete"

```











### Sessions

The instances of an agent are called sessions. Session represents a multi-turn conversation between user and an agent.

We can already start a session for our agent:

```typescript
const av = new AgentView({
    baseUrl: "http://localhost:3000"
});

const { token } = await av.auth(); // authenticate as an anonymous user

// Create session
const session = await av.createSession({ 
    agent: "very_simple_agent",
    token
})

// Fetch session
const fetchedSession = await av.getSession({ id: session.id})
```

Sessions can have custom metadata. Imagine that we create a shopping assistant which can run on the product page of e-commerce website. In that case each session must have `product_id` assigned.

Let's update our agent config:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            }
        }
    ]
});
```

`metadata` is an object, the keys are metafield ids, and the value is schema.

Now if we want to create a new session we **must** provide `product_id` (since it's not `.optional()`):

```ts
const session = await av.createSession({ 
    agent: "very_simple_agent",
    metadata: { 
        product_id: "beautiful_pants_123"
    },
    token
})
```

If you tried to call `createSession` without providing `product_id` the `createSession` function would throw an error.

## Runs and Items

Below is a simple agent with a single run. The run has user message input (string), reasoning blocks, and assistant message output, also as a string:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string(),
                            },
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ]
        },
        // ...
    ]
})
```

Let's unpack.


### Items 

The core part of each session is an ordered list of so called Items. Item is a totally arbitrary object that represents that something happened in the history of our session and it needs to be stored for consistent continuation:
- user or assistant messages
- reasoning blocks
- tools (function calls, MCP, server tools)
- handoffs to other agents in multi-agent systems
- custom

It's worth highlighting that Item in AgnetView is just a JSON, it can be *anything*. AgentView goal is to be as unopinionated as possible and therefore doesn't force you into any pre-defined message formats. This allows to make it really framework-agnostic. For example, it's trivial to just send items from AgentsSDK, Responses API, AI SDK, LangChain, without any trouble.

### Runs

You add items to a session via runs. Run is a special object helping in managing lifecycle of the session.

Run represents a single turn of the conversation. It always starts with an user action, usually just a user message, an `input` item. Then the any number of items might be produced, and in the end the `output` item must be added, which ends the run. Run in more complex systems will usually consist of multiple calls to the LLMs.

You start a run by providing an input item:

```ts
const run = await av.createRun({ 
    input: { 
        type: "message", 
        role: "user",
        content: "Hello dear sir."
    },
    sessionId: "SESSION_ID", // if you leave it empty it will create a new session automatically
    version,
    token
})

console.log(run.status) // in_progress
```

While your agent is running you can keep adding the items:

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    items: [
        { 
            type: "reasoning", 
            content: "Thinking hard..."
        },
        { 
            type: "reasoning", 
            content: "Thinking even harder..."
        }
    ],
    token
})

console.log(run.status) // in_progress
```
You can call `av.updateRun` as many times as you need while your agent is running. Items from `updateRun` call will be always *appended* to the previous items.

The moment you send an `output` item, the run will be marked as `complete`:

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    items: [
        { 
            type: "reasoning", 
            content: "Last thinking..."
        },
        { 
            type: "message",
            role: "assistant", 
            content: "Ugh that was a hard one. Hello!"
        }
    ],
    token
})

console.log(run.status) // complete
```

### Failing runs

It's possible that you agent might encounter an error during a run. You can set mark a run as failed easily:

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    status: "failed",
    failReason: {
        message: "LLM model error.",
        details: ...
    },
    token
})

console.log(run.status) // failed
```

### Accessing session history

You can access the session history items by calling `getSession`:

```ts
const session = await av.getSession({ id: session.id })
console.log(session.history) // the list of all the items from successful runs (if run fails it's items are not part of history)
console.log(session.lastRun) // last run
console.log(session.lastRun.status) // in_progress, complete or failed
console.log(session.runs) // all the session runs
```

### Retrying failed sessions

AgentView allows you to implement retry logic for the failed runs.

Any time you run a `createRun` function on a session which last run was `failed`, AgentView will discard the last failed run (it's items will be removed from the history):

```ts
if (session.lastRun === "failed") { // retry logic
    av.createRun({
        input: session.lastRun.input,
        sessionId,
        version,
        token
    })
}
```

If your agent is capable of resuming the run based on partial items from the previous run, just do this:

```ts
if (session.lastRun === "failed") { // retry logic
    av.createRun({
        items: session.lastRun.items,
        sessionId,
        version,
        token
    })
}
```

It will initiate a new run with all the items from the previously failed run.

### Built-in Error Handling

AgentView makes sure the state of your app is always correct. Here's a list of scenarios that will result in throwing an error:
1. Incorrect input item passed to `createRun`.
2. Creating a run while another run is in progress.
3. Adding items or changing state on a finished run.
4. Creating a run with incompatible version (semantic versioning).

AgentView SDK throws exceptions in a format ready to send over directly to your client as HTTP error responses (it has body and status code):

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';

const app = new Hono();
const client = new OpenAI()
const av = new AgentView()
const version = "0.2.1"
const agent = "my_simple_agent"

app.post('/chat', async (c) => {
  const { sessionId, input, token } = await c.req.json();

  // create or get session
  const session = sessionId ?
    await av.getSession(sessionId):
    await av.createSession({ agent })

  // create run
  const run = await av.createRun({ input, sessionId: session.id, token, version });

  // generate response
  const response = await client.responses.create({
    model: "gpt-5-nano",
    input: [...session.history, input]
  });

  // push items and close run (the last item of output is assistant message)
  await av.updateRun({
    id: run.id
    items: response.output,
  })

  return c.json({
    output: response.output
  })
})

// Handle AgentViewError
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json(error.body, error.status);
  }
});

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

Now if someone calls `/chat` 2 times in a row with the same `input` and `sessionId`, the endpoint will very gracefully fail.


### Long running jobs

The run will automatically be set as failed after 1 minute of inactivity. If your agent is long running you can send heartbeat to tell AgentView Server that the run is still processing:

```ts
await av.ping({ runId: "RUN_ID" })
```

### Removing items

You can't remove items from the session. The core foundation behind AgentView is that whenever you send an item to a client (or agentview), the end user saw it. If end user saw it, then anyone using AgentView Studio should also be able to see it, exactly as user did. 

### Session `state`

Sometimes it's hard to represent a session state just with array of Items. For example, durign the course of the session you might create session memories, or additional artifacts needed for thread summarisation (to prevent context overflow). You might want to store them between runs, but, it's unnatural to keep them as Items.

For that purpose AgentView introduced the concept of the state. State is totally arbitrary object bounded to a session available via `session.state`.

```ts
const run = await av.updateRun({ 
    items: [
        { 
            type: "message", 
            role: "assistant"
            content: "Thank you John, you're very kind, hopefully our recommendations will help treat your concerns."
        }
    ],
    state: {
        userName: "John Doe",
        skincareProfile: "John suffers from acne, retinol didn't help."
    }
    runId: "RUN_ID",
    token
})

const session = await av.getSession({ id })
console.log(session.state) // { userName: "John Doe", skincareProfile: "..." }
```

You always get access to the *last* instance of the state. However, AgentView tracks the full history of the state changes so that you can copy the session up to a particular moment in time and continue it with different scenario.

### Run metadata

Similary to sessions, runs can have their metadata. It's helpful when you want to store usage data, trace id for observability platform link, etc.

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    metadata: {
        trace_id: "TRACE_ID", // for example Langfuse trace id
        cost: "0.15"
    },
    token
})
```

### Mutliple runs

Session might have multiple runs available. Whenever you initiate the run, AgentView tries to match schema of an input item to the run. If there is more than 1 match, it results in an error (see "item matching").

### Validation

As you saw AgentView is build around schemas. You can set `validation` property to set the proper level of validation:

```ts
export const config = defineConfig({
    validation: {
        sessionMetadata: "passthrough"
        runMetadata: "passthrough"
        state: "passthrough"
        items: {
            input: "passthrough",
            output: "passthrough",
            steps: ["passthrough", "allow-unknown"]
        }
    }
})
```

The strategies come from Zod:
- `passthrough` - allow unknown keys and save them
- `strip` - allow unknown keys and discard them
- `strict` - do not allow for unknown keys

For `passthrough` and `strip` the default schema for underlying object is `z.any()`. It means that if you don't set `session.metadata` in the config, you'll allow to set it to any value.

In terms of `validation.items.steps` you can set extra flag called `allow-unknown`. It says that if no step item can be matched, AgentView will still allow for saving.


### Users and authentication

Every session in AgentView is connected with a User. This is very helpful becaseu we might have multiple sessions connected with teh same user which allows for memory, etc.

Every session operation requires an authentication token that uniquely idenfies the request with a particular user.

#### Anonymous sessions

Imagine you're building a shopping assistant. Some user enters your e-commerce and is not logged in (might not even have an account). We don't know anything about this user but still want her to be able to chat.

The anonymous user is created like this

```ts
const { token } = av.auth()
```

Under the hood it creates a new user and sends over an authentication token.

#### Existing users

Imagine user is logged in in the e-commerce platform. It should be possible to somehow "connect" this user with the AgentView user instance.

In order to achieve that, you can use `id_token` JWT: 
```ts
const { token } = av.auth({ id_token: 'proof_of_identity_jwt' })
```

`id_token` is JWT that is a "proof of identity". It should be short-lived and be signed with AgentView key and have following body:

```json
{
    "external_id": "unique_user_id_from_external_platform"
}
```

All you need to do is create such token with external user platform id, sign it with your AgnetView private key, and send it via `id_token`. This will allow AgentView to find a correct user based on `external_id`.

## Items

type: "agentview:message"


## --- todo ---

// Validation

- maybe different flow?
- what if no input is there... it's OK
- if multiple runs are there and NO INPUT MATCHES - and what if TWO INPUT MATCHES§§

// messages (grouping), items matching (tool calls!)

Security:
- public key -> full access
- private key -> write access

Studio: 
- displayProperties
- inputItems
- inputForm (session context)
- scores



#### Questions

1. Do we even need "output" item? -> isn't just sending items and closing run enough and we treat output as the last one?
2. ... and do we even need INPUT item? -> the FIRST could be an input item.

I mean... without validation we could essentially simplify this 


#### Commnets


Validation

```ts
{
    // inexisting metafield will be saved!
    sessionMetadata: "passthrough"
    runMetadata: "passthrough"

    // state is easy
    state: "passthrough"

    // 
    items: {
        input: "passthrough",
        output: "passthrough",
        steps: ["passthrough", "allow-unknown"]
    }
}


    // DEFAULTS for input, output: z.any(). Same as for state, session metadata, runMetadata etc... 

    // Later we can extend inputs and outputs to ["allow-unknown"] too

    // Values for ARRAYS (items)
    // - passthrough/strict/strip -> *must match one* -> then zod. 
    // 
    // it kinda works as if it was a UNION in Zod. And it's OK.
    //
    // The only behaviour missing is whether we "allow unknown".
    // So... if Zod matches some item -> it's always a Zod POLICY.
    // But when it doesn't... 
```