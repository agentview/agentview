# Architecture overview

AgentView consists of 2 main parts: Server and Studio. All the configuration is managed in code via `agentview.config.tsx` file.

### Server

**Server** is a backend part. It is capable of storing all your agent sessions state, validation and resumability, managing users authentication and memories, and a lot more that your agent needs. It communicates with outer world via API called AgentView API.

For now, you must set it up locally via `docker-compose.yml`, we'll ship Cloud version soon.

### Studio

The **Studio** is a powerful and customisable session viewer. It's shipped as a React package. When you look at our example from *Getting Started* you'll see that Studio is a Vite app run in this way:


```ts
import "./styles.css";
import { renderStudio } from "agentview";
import agentviewConfig from "./agentview.config";

renderStudio(
    document.getElementById("agentview"), 
    agentviewConfig
);
```

Since it's React package is super easy to provide your own custom React components. 

### Configuration

All the AgentView configuration is in `agentview.config.tsx` file. This file lives in Studio project and must be provided to Studio in `renderStudio(...)`.

All the agent definition information (mostly schemas) is sent to the AgentView Server. Thanks to this Server can do proper validation and prevent incorrect data getting into your system.

In order to make this connection work you set `server` property in `agentview.config.tsx` file:

```typescript
export default defineConfig({
    baseUrl: process.env.AGENTVIEW_API_URL,
    // ...
})
```

Now when you run `npm run dev` in your Studio project, each time `agentview.config.tsx` is changed, it's gonna be synchronised with the Server.

# API

### Basic Usage 

The core object in AgentView is an agent. Agent represents an entity that is responsible for doing one job (for example being a shopping assistant).

Here's the simplest possible definition of an agent:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent"
        }
    ]
});
```

This is enough to create a session, add a run with items:

```ts
// Create a client - a thin wrapper over AgentView API
const av = new AgentView({
    baseUrl: "http://localhost:3000",
    apiKey: "AGENTVIEW_SECRET_KEY"
});

// Authenticate as an anonymous user
const { token } = await av.auth(); 

// Create session
const session = await av.createSession({
    agent: "very_simple_agent",
    token
})

// Create a run with input item
const run = await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version,
    token,
})

console.log(run.status) // in_progress

async function mockLLMCall() {
    await new Promise(resolve => setTimeout(resolve, 1000)); // sleep 1s
    return [
        { type: "reasoning", content: "Hmm, this is a very complex question..." }
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ]
}

const outputItems = await mockLLMCall() // build an output itms

// add output items and end the run
await av.updateRun({
    id: run.id,
    items: outputItems,
    status: "complete",
    token,
})

// Fetch session
const updatedSession = await av.getSession({ id: session.id, token })

console.log(updatedSession.history)
/**
 * [
 *  { type: "message", role: "user", content: "Hello, I'm Bob" },
 *  { type: "reasoning", content: "Hmm, this is a very complex question..." },
 *  { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
 * ]
 */

console.log(updatedSession.lastRun.status) // "complete"

```

There are a bunch of things that happened, let's unpack.

#### Create a Client

```ts
const av = new AgentView({
    baseUrl: "http://localhost:3000",
    apiKey: "AGENTVIEW_SECRET_KEY"
});
```

`AgentView` is a thin wrapper over AgentView API.


#### Authenticate a User

```ts
const { token } = await av.auth(); 
```

Every Session in AgentView belongs to a User. That's why any time you make any operation on a session (create, update, delete) you must provide a user authentication token. In this example we make anonymous authentication, under the hood AgentView creates a new User.

Read more about Authentication here.

### Sessions

Session represents a multi-turn conversation between user and an agent. It's kind of like the instance of an agent.

Create a session:

```typescript
const session = await av.createSession({ 
    agent: "very_simple_agent",
    token
})
```

Read session:

```typescript
const session = await av.getSession({ 
    id: "session_id",
    token
})

console.log(session.history) // session items
console.log(session.lastRun) // last run
console.log(session.lastRun.status) // last run status
console.log(session.runs) // all runs
```

### Session Metadata

Sessions can have custom metadata. AgentView aims to be as flexible as possible, that's why every object can be extended custom metadata.

Imagine you're building a shopping assistant which can run on the product page of e-commerce website. In that case each session must have `product_id` assigned.

Let's update our agent config:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string()
            }
        }
    ]
});
```

`metadata` is an object with so called "metafields". Each metafield has a key (name) and it's Zod schema.

Now when we create a new session we **must** provide `product_id` (since it's not `.optional()`):

```ts
const session = await av.createSession({ 
    agent: "very_simple_agent",
    metadata: { 
        product_id: "beautiful_pants_123",
    },
    token
})
```

If we tried to call `createSession` without providing `product_id` the `createSession` function would throw an error.

By default, if metafield is **not** defined in metadata, it's allowed to add it (no validation). If you want to override it:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            metadata: {
                product_id: z.string(),
            },
            allowUnknownMetadata: false
        }
    ]
});
```

### Items

The core part of each session is an ordered list of Session Items, or just Items. Item is a totally arbitrary object that represents that something happened in the history of our session and it needs to be stored for consistent continuation:
- user or assistant messages
- reasoning blocks
- tools (function calls, MCP, server tools)
- handoffs to other agents in multi-agent systems
- custom

It's worth highlighting that Item in AgnetView is just a JSON, it can be *anything*. AgentView goal is to be as unopinionated as possible and therefore doesn't force you into any pre-defined message formats. This allows to make it really framework-agnostic. For example, it's trivial to just send items from AgentsSDK, Responses API, AI SDK, LangChain, without any trouble.

### Runs

You add items to a session via runs. Run is a special object helping in managing lifecycle of the session.

Run represents a single turn of the conversation. It starts with a user action, usually just a user message, an input item. Then the any number of items might be produced, and in the end the output item must be added, which ends the run. Run in more complex systems will usually consist of multiple calls to the LLMs, tool calls, etc.

Here's how to create a run with a user message input message.

```ts
const run = await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version,
    token,
})

console.log(run.status) // in_progress
```

#### Run status

The run `status` can be `in_progress`, `complete` or `failed`. After the run is created it automatically has `in_progress` value. When the run is `in_progress`, the session won't accept any new runs. Below, the second `av.createRun` will result in an exception:

```ts
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version,
    token,
})

await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello, I'm Bob" }
    ],
    sessionId: session.id
    version,
    token,
}) // throws AgentViewError, you can have only one in_progress run at a time!
```

#### Adding items

You can call `av.updateRun` as many times as you want to keep adding items.

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "reasoning", content: "Thinking..." },
        { type: "reasoning", content: "Thinking even harder..." }
    ],
    token,
})
```

 We highly recommend using streaming and sending data to AgentView as soon as they appear. It allows for better retry / resume logic later. 

 #### Ending Run

 If the run finished successfully, just set the status to `complete`:

```ts
await av.updateRun({
    id: run.id,
    items: [
        { type: "message", role: "assistant", content: "Hey, nice to meet you :)" }
    ],
    status: "complete",
    token,
})
```

It's possible that you agent might encounter an error during a run. You can set mark a run as failed easily:

```ts
const run = await av.updateRun({ 
    id: run.id,
    status: "failed",
    failReason: {
        message: "LLM model error.",
        details: ...
    },
    token
})
```

When the run is finished (`failed` or `complete`), you can't change its status nor add items anymore. 

#### Retrying failed sessions

If the last session run was failed, you can still create a new run. If you do it, the last failed run items will be removed from the history and the items from your new run will be appended to the last successful run (the one before the failed one):

Retry logic with keeping only the user message:

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: [session.lastRun.items[0]],
        sessionId,
        version,
        token
    })
}
```

Resume (all the items from previous failed run preserved):

```ts
if (session.lastRun === "failed") { // retry logic
    await av.createRun({
        items: session.lastRun.items,
        sessionId,
        version,
        token
    })
}
```

#### Removing items

You can't remove items from the session. The core foundation behind AgentView is that whenever you send an item to a client (or agentview), the end user saw it. If end user saw it, then anyone using AgentView Studio should also be able to see it, exactly as user did. 

#### Run metadata

Similary to sessions, runs can be extended with custom metadata. It's helpful when you want to store usage data, trace id for observability platform link, etc.

```ts
const run = await av.updateRun({ 
    id: "RUN_ID",
    metadata: {
        trace_id: "TRACE_ID", // for example Langfuse trace id
        cost: "0.15"
    },
    token
})
```

Similar to sessions, by default unknown keys are allowed. You can change this behaviour by provide schema and settings `allowUnk

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    metadata: {
                        trace_id: z.string()
                    },
                    allowUnknownMetadata: false,
                    // ...
                }
            ]
        }
    ]
});
```

#### Long running jobs

The run will automatically be set as failed after 1 minute of inactivity. If your agent is long running you can send heartbeat to tell AgentView Server that the run is still processing:

```ts
await av.ping({ runId: "RUN_ID" })
```


### Items Validation

The default settings of AgentView are very relaxed not to overload you with annoying errors during development. However, you can provide schemas to provide stronger validation.

#### Input and Output

The following code says that `very_simple_agent` has a single run.

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ]
        }
        // ...
    ]
})
```

Here's what's happens now:
1. When you create a run with `av.createRun`, the first item in `items` array is treated as "input".
2. AgentView scans all the available runs from the agent config and matches the `input`.
3. If it found a matching run, all the validation will be done according this run settings. So in this case, it's gonna make sure that the last item in items array (output) matches the `output` schema.


```ts
// Correct, output matches input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", role: "assistant", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
    version,
    token
})

// Throws, incorrect output for a given input
await av.createRun({
    items: [
        { type: "message", role: "user", content: "Hello I'm Bob." }
        { type: "message", content: "Hello Bob, how are you?" } // no "role"
    ],
    status: "complete",
    version,
    token
})
```

By default, if AgnetView can't find a run based on input item, it will fallback to "unknown run" which allows for any item shape. So this is still possible:

```ts
// Can't match any run -> unknown run -> allow
await av.createRun({
    items: [
        { type: "blah" }
        { type: "message", content: "Hello Bob, how are you?" }
    ],
    status: "complete",
    version,
    token
})
```

You can disable this behaviour:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                // ...
            ],
            allowUnknownRuns: false
        }
        // ...
    ]
})
```

Now, an input item of new run **must** match at least one input from the runs array.

#### Steps

For now we just validated input and output, which is first and and last items of a run. The items between input and output are called "steps". You can make sure steps conform to the schemas you provide:

```typescript
export default defineConfig({
    // ...
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: {
                        schema: {
                            type: "message",
                            role: "user",
                            content: z.string(),
                        }
                    },
                    steps: [
                        {
                            schema: {
                                type: "reasoning",
                                content: z.string()
                            }
                        }
                    ]
                    output: {
                        schema: {
                            type: "message",
                            role: "assistant",
                            content: z.string(),
                        }
                    }
                }
            ],
            allowUnknownSteps: false
        },
        // ...
    ]
})
```

In this example only the reasoning steps with string content are allowed. Please keep in mind you must set `allowUnknownSteps` to `false`. Without it, even if no matching stpe is found, AgentView will treat the step as unknown and allow it to be added.

#### Tool calls

Tool calls are pretty special in a sense that there always come in pairs. There's a tool call item and tool result items, usually related to each other by tool call id.

AgentView allows to represent this in the schema:

```typescript
export default defineConfig({
    agents: [
        {
            name: "very_simple_agent",
            runs: [
                {
                    input: /* ... */,
                    output: /* ... */,
                    steps: [
                        {
                            schema: {
                                type: "function_call",
                                name: "weather_tool",
                                callId: z.string().meta({ callId: true })
                            },
                            callResult: {
                                schema: {
                                    type: "function_call_result",
                                    callId: z.string().meta({ callId: true })
                                },
                            }
                        },
                        // ...
                    ]
                }
            ],
            allowUnknownSteps: false
        }
    ]
})
```

In this scenario AgentView will make sure that every weather function call has appropriate result.

#### Strict validation

By default the items are matched loosely, which means that unknown keys will be treated as a match and saved. You can force strict matching by setting `allowUnknownItemKeys` flag to `false`:

```typescript
export default defineConfig({
    agents: [
        {
            name: "my_super_agent",
            runs: [
                // ...
            ],            
            allowUnknownItemKeys: false
        }
    ]
})
```

### Session `state`

Sometimes it's hard to represent a session state just with array of Items. For example, durign the course of the session you might create session memories, or additional artifacts needed for thread summarisation (to prevent context overflow). You might want to store them between runs, but, it's unnatural to keep them as Items.

For that purpose AgentView introduced the concept of the state. State is totally arbitrary object bounded to a session available via `session.state`.

```ts
const run = await av.updateRun({ 
    items: [
        { 
            type: "message", 
            role: "assistant"
            content: "Thank you John, you're very kind, hopefully our recommendations will help treat your concerns."
        }
    ],
    state: {
        userName: "John Doe",
        skincareProfile: "John suffers from acne, retinol didn't help."
    }
    id: run.id,
    token
})

const session = await av.getSession({ id })
console.log(session.state) // { userName: "John Doe", skincareProfile: "..." }
```

You always get access to the *last* instance of the state. However, AgentView tracks the full history of the state changes so that you can copy the session up to a particular moment in time and continue it with different scenario.




### Error Handling

As you can see, AgentView does a lot to make sure your app state is always correct. It handles items and metadata validation and orchestrates the session lifecycle thanks to a run state.

Any time an error occurs, AgnetView will throw an exception which is an instance of `AgentViewError`. It has `body` and `statusCode` propreties so that it's trivial to just redirect it directly to the user as HTTP responses from your endpoint:

```typescript
import 'dotenv/config'
import { Hono } from 'hono'
import { serve } from '@hono/node-server'
import { AgentView, AgentViewError } from "agentview";
import { OpenAI } from 'openai';

const app = new Hono();
const client = new OpenAI()
const av = new AgentView()
const version = "0.2.1"
const agent = "my_simple_agent"

app.post('/chat', async (c) => {
  const { sessionId, input, token } = await c.req.json();

  // create or get session
  const session = sessionId ?
    await av.getSession(sessionId):
    await av.createSession({ agent })

  // create run
  const run = await av.createRun({ input, sessionId: session.id, token, version });

  // generate response
  const response = await client.responses.create({
    model: "gpt-5-nano",
    input: [...session.history, input]
  });

  // push items and close run (the last item of output is assistant message)
  await av.updateRun({
    id: run.id
    items: response.output,
  })

  return c.json({
    output: response.output
  })
})

// Handle AgentViewError
app.onError((error, c) => {
  if (error instanceof AgentViewError) {
    return c.json(error.body, error.status);
  }
});

serve({
  fetch: app.fetch,
  port: 3000
}, (info) => {
  console.log(`Agent API server is running on http://localhost:${info.port}`)
})
```

You can now call from your browser:

```ts

```


### Users and authentication

Every session in AgentView is connected with a User. This is very helpful becaseu we might have multiple sessions connected with teh same user which allows for memory, etc.

Every session operation requires an authentication token that uniquely idenfies the request with a particular user.

#### Anonymous sessions

Imagine you're building a shopping assistant. Some user enters your e-commerce and is not logged in (might not even have an account). We don't know anything about this user but still want her to be able to chat.

The anonymous user is created like this

```ts
const { token } = av.auth()
```

Under the hood it creates a new user and sends over an authentication token.

#### Existing users

Imagine user is logged in in the e-commerce platform. It should be possible to somehow "connect" this user with the AgentView user instance.

In order to achieve that, you can use `id_token` JWT: 
```ts
const { token } = av.auth({ id_token: 'proof_of_identity_jwt' })
```

`id_token` is JWT that is a "proof of identity". It should be short-lived and be signed with AgentView key and have following body:

```json
{
    "external_id": "unique_user_id_from_external_platform"
}
```

All you need to do is create such token with external user platform id, sign it with your AgnetView private key, and send it via `id_token`. This will allow AgentView to find a correct user based on `external_id`.

## Items




```
__agentviewType: "message"
field1: ...
field2: ...
```


<!-- type: "agentview:endMessage" -->







## --- todo ---

// messages (grouping) -> let's force this onto user!!! Seriously, fuck it for now. 
// Consider moving Session Items and Session State up in docs. 


Security:
- public key -> full access
- private key -> write access

If there's apiKey -> we don't have to "auth" users. It makes no sense. We can simply "find them" and "provide the userId". 
There should be createClient() function.





Studio: 
- displayProperties
- inputItems
- inputForm (session context)
- scores

```ts
// Create a client - a thin wrapper over AgentView API
const av = new AgentView({
    baseUrl: "http://localhost:3000",
    apiKey: "AGENTVIEW_SECRET_KEY" -> PRIVATE SECRET KEY -> SIMULATIONS!!!
});

```